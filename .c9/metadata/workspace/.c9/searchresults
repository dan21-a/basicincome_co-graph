{"changed":true,"filter":false,"title":"Search Results","tooltip":"/.c9/searchresults","value":"Searching for \u0001pointer-events:auto;\u0001 in\u0001the active file\u0001 (Found 3 matches in 1 file)\n\n/index.html:\n\t86: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" id=\"zoomInButton\" value=\"+\" onclick=\"zoomIn();\" disabled=\"disabled\"/><br/>\n\t87: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" value=\"&ndash;\" onclick=\"zoomOut();\"/>\n\t97: <div id=\"information\" style=\"opacity:0.8; background-color:#fff; position:absolute; top:704px; width:100%; border: 1px solid #c8c8c8; margin-left:-1px; pointer-events:auto;\">\n\nFound 3 matches in 1 file \n\n","undoManager":{"mark":-1,"position":20,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":0,"column":1},"action":"insert","lines":[" "]},{"start":{"row":0,"column":0},"end":{"row":0,"column":1},"action":"remove","lines":[" "]},{"start":{"row":0,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["Searching for \u0001WebSocket\u0001 in\u0001/basicincome_co/services\u0001","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":0},"end":{"row":3,"column":0},"action":"insert","lines":["/basicincome_co/services/ripple_connection.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3,"column":0},"end":{"row":6,"column":0},"action":"insert","lines":["\t3: module.service('$ripple_connection', ['$rootScope', '$network', function($scope, WebSocket, $network)","","Found 1 match in 1 file ",""]}]}],[{"group":"doc","deltas":[{"start":{"row":6,"column":0},"end":{"row":7,"column":0},"action":"insert","lines":["",""]},{"start":{"row":0,"column":54},"end":{"row":0,"column":80},"action":"insert","lines":[" (Found 1 match in 1 file)"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":7,"column":0},"action":"remove","lines":["Searching for \u0001WebSocket\u0001 in\u0001/basicincome_co/services\u0001 (Found 1 match in 1 file)","","/basicincome_co/services/ripple_connection.js:","\t3: module.service('$ripple_connection', ['$rootScope', '$network', function($scope, WebSocket, $network)","","Found 1 match in 1 file ","",""]},{"start":{"row":0,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["Searching for \u0001WebSocket\u0001 in\u0001the entire project\u0001","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":0},"end":{"row":3,"column":0},"action":"insert","lines":["/ripple-0.7.201-debug.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3,"column":0},"end":{"row":7,"column":0},"action":"insert","lines":["\t59: \teval(\"// Remote access to a server.\\r\\n// - We never send binary data.\\r\\n// - We use the W3C interface for node and browser compatibility:\\r\\n//   http://www.w3.org/TR/websockets/#the-websocket-interface\\r\\n//\\r\\n// This class is intended for both browser and node.js use.\\r\\n//\\r\\n// This class is designed to work via peer protocol via either the public or\\r\\n// private websocket interfaces.  The JavaScript class for the peer protocol\\r\\n// has not yet been implemented. However, this class has been designed for it\\r\\n// to be a very simple drop option.\\r\\n//\\r\\n// YYY Will later provide js/network.js which will transparently use multiple\\r\\n// instances of this class for network access.\\r\\n//\\r\\n\\r\\n// npm\\r\\nvar EventEmitter = require(27).EventEmitter;\\r\\nvar util         = require(28);\\r\\n\\r\\nvar Request      = require(14).Request;\\r\\nvar Server       = require(11).Server;\\r\\nvar Amount       = require(2).Amount;\\r\\nvar Currency     = require(3).Currency;\\r\\nvar UInt160      = require(15).UInt160;\\r\\nvar Transaction  = require(5).Transaction;\\r\\nvar Account      = require(16).Account;\\r\\nvar Meta         = require(6).Meta;\\r\\nvar OrderBook    = require(17).OrderBook;\\r\\nvar PathFind     = require(18).PathFind;\\r\\nvar RippleError  = require(19).RippleError;\\r\\n\\r\\nvar utils        = require(9);\\r\\nvar config       = require(12);\\r\\nvar sjcl         = require(10);\\r\\n\\r\\n/**\\r\\n    Interface to manage the connection to a Ripple server.\\r\\n\\r\\n    This implementation uses WebSockets.\\r\\n\\r\\n    Keys for opts:\\r\\n\\r\\n      trace\\r\\n      max_listeners      : Set maxListeners for remote; prevents EventEmitter warnings\\r\\n      connection_offset  : Connect to remote servers on supplied interval (in seconds)\\r\\n      trusted            : truthy, if remote is trusted\\r\\n      max_fee            : Maximum acceptable transaction fee\\r\\n      fee_cushion        : Extra fee multiplier to account for async fee changes.\\r\\n      servers            : Array of server objects with the following form\\r\\n\\r\\n         { \\r\\n              host:    <string>\\r\\n            , port:    <number>\\r\\n            , secure:  <boolean>\\r\\n         }\\r\\n\\r\\n    Events:\\r\\n      'connect'\\r\\n      'connected' (DEPRECATED)\\r\\n      'disconnect'\\r\\n      'disconnected' (DEPRECATED)\\r\\n      'state':\\r\\n      - 'online'        : Connected and subscribed.\\r\\n      - 'offline'       : Not subscribed or not connected.\\r\\n      'subscribed'      : This indicates stand-alone is available.\\r\\n\\r\\n    Server events:\\r\\n      'ledger_closed'   : A good indicate of ready to serve.\\r\\n      'transaction'     : Transactions we receive based on current subscriptions.\\r\\n      'transaction_all' : Listening triggers a subscribe to all transactions\\r\\n                          globally in the network.\\r\\n\\r\\n    @param opts      Connection options.\\r\\n    @param trace\\r\\n*/\\r\\n\\r\\nfunction Remote(opts, trace) {\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  var self  = this;\\r\\n\\r\\n  this.trusted               = Boolean(opts.trusted);\\r\\n  this.local_sequence        = Boolean(opts.local_sequence); // Locally track sequence numbers\\r\\n  this.local_fee             = (typeof opts.local_fee === 'undefined') ? true : Boolean(opts.local_fee); // Locally set fees\\r\\n  this.local_signing         = (typeof opts.local_signing === 'undefined') ? true : Boolean(opts.local_signing);\\r\\n  this.fee_cushion           = (typeof opts.fee_cushion === 'undefined') ? 1.5 : Number(opts.fee_cushion);\\r\\n  this.max_fee               = (typeof opts.max_fee === 'undefined') ? Infinity : Number(opts.max_fee);\\r\\n  this.id                    = 0;\\r\\n  this.trace                 = Boolean(opts.trace);\\r\\n  this._server_fatal         = false; // True, if we know server exited.\\r\\n  this._ledger_current_index = void(0);\\r\\n  this._ledger_hash          = void(0);\\r\\n  this._ledger_time          = void(0);\\r\\n  this._stand_alone          = void(0);\\r\\n  this._testnet              = void(0);\\r\\n  this._transaction_subs     = 0;\\r\\n  this.online_target         = false;\\r\\n  this._online_state         = 'closed'; // 'open', 'closed', 'connecting', 'closing'\\r\\n  this.state                 = 'offline'; // 'online', 'offline'\\r\\n  this.retry_timer           = void(0);\\r\\n  this.retry                 = void(0);\\r\\n\\r\\n  this._load_base            = 256;\\r\\n  this._load_factor          = 256;\\r\\n  this._fee_ref              = 10;\\r\\n  this._fee_base             = 10;\\r\\n  this._reserve_base         = void(0);\\r\\n  this._reserve_inc          = void(0);\\r\\n  this._connection_count     = 0;\\r\\n  this._connected            = false;\\r\\n  this._connection_offset    = 1000 * (Number(opts.connection_offset) || 5);\\r\\n  this._submission_timeout   = 1000 * (Number(opts.submission_timeout) || 10);\\r\\n\\r\\n  this._received_tx          = { };\\r\\n  this._cur_path_find        = null;\\r\\n\\r\\n  // Local signing implies local fees and sequences\\r\\n  if (this.local_signing) {\\r\\n    this.local_sequence = true;\\r\\n    this.local_fee      = true;\\r\\n  }\\r\\n\\r\\n  this._servers        = [ ];\\r\\n  this._primary_server = void(0);\\r\\n\\r\\n  // Cache information for accounts.\\r\\n  // DEPRECATED, will be removed\\r\\n  this.accounts = {\\r\\n    // Consider sequence numbers stable if you know you're not generating bad transactions.\\r\\n    // Otherwise, clear it to have it automatically refreshed from the network.\\r\\n\\r\\n    // account : { seq : __ }\\r\\n  };\\r\\n\\r\\n  // Account objects by AccountId.\\r\\n  this._accounts = { };\\r\\n\\r\\n  // OrderBook objects\\r\\n  this._books = { };\\r\\n\\r\\n  // Secrets that we know about.\\r\\n  this.secrets = {\\r\\n    // Secrets can be set by calling set_secret(account, secret).\\r\\n\\r\\n    // account : secret\\r\\n  };\\r\\n\\r\\n  // Cache for various ledgers.\\r\\n  // XXX Clear when ledger advances.\\r\\n  this.ledgers = {\\r\\n    current : {\\r\\n      account_root : {}\\r\\n    }\\r\\n  };\\r\\n\\r\\n  // Fallback for previous API\\r\\n  if (!opts.hasOwnProperty('servers')) {\\r\\n    opts.servers = [ \\r\\n      {\\r\\n        host:     opts.websocket_ip,\\r\\n        port:     opts.websocket_port,\\r\\n        secure:   opts.websocket_ssl,\\r\\n        trusted:  opts.trusted\\r\\n      }\\r\\n    ];\\r\\n  }\\r\\n\\r\\n  opts.servers.forEach(function(server) {\\r\\n    var pool = Number(server.pool) || 1;\\r\\n    while (pool--) { self.add_server(server); };\\r\\n  });\\r\\n\\r\\n  // This is used to remove Node EventEmitter warnings\\r\\n  var maxListeners = opts.maxListeners || opts.max_listeners || 0;\\r\\n  this._servers.concat(this).forEach(function(emitter) {\\r\\n    emitter.setMaxListeners(maxListeners);\\r\\n  });\\r\\n\\r\\n  function listener_added(type, listener) {\\r\\n    if (type === 'transaction_all') {\\r\\n      if (!self._transaction_subs && self._connected) {\\r\\n        self.request_subscribe('transactions').request();\\r\\n      }\\r\\n      self._transaction_subs += 1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function listener_removed(type, listener) {\\r\\n    if (type === 'transaction_all') {\\r\\n      self._transaction_subs -= 1;\\r\\n      if (!self._transaction_subs && self._connected) {\\r\\n        self.request_unsubscribe('transactions').request();\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  this.on('newListener', listener_added);\\r\\n  this.on('removeListener', listener_removed);\\r\\n}\\r\\n\\r\\nutil.inherits(Remote, EventEmitter);\\r\\n\\r\\n// Flags for ledger entries. In support of account_root().\\r\\nRemote.flags = {\\r\\n  account_root : {\\r\\n    PasswordSpent:   0x00010000,\\r\\n    RequireDestTag:  0x00020000,\\r\\n    RequireAuth:     0x00040000,\\r\\n    DisallowXRP:     0x00080000\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction isTemMalformed(engine_result_code) {\\r\\n  return (engine_result_code >= -299 && engine_result_code <  199);\\r\\n};\\r\\n\\r\\nfunction isTefFailure(engine_result_code) {\\r\\n  return (engine_result_code >= -299 && engine_result_code <  199);\\r\\n};\\r\\n\\r\\nRemote.from_config = function (obj, trace) {\\r\\n  var serverConfig = typeof obj === 'string' ? config.servers[obj] : obj;\\r\\n\\r\\n  var remote = new Remote(serverConfig, trace);\\r\\n\\r\\n  function initialize_account(account) {\\r\\n    var accountInfo = config.accounts[account];\\r\\n    if (typeof accountInfo === 'object') {\\r\\n      if (accountInfo.secret) {\\r\\n        // Index by nickname ...\\r\\n        remote.set_secret(account, accountInfo.secret);\\r\\n        // ... and by account ID\\r\\n        remote.set_secret(accountInfo.account, accountInfo.secret);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof config.accounts === 'object') {\\r\\n    for (var account in config.accounts) {\\r\\n      initialize_account(account);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return remote;\\r\\n};\\r\\n\\r\\nRemote.create_remote = function(options, callback) {\\r\\n  var remote = Remote.from_config(options);\\r\\n  remote.connect(callback);\\r\\n  return remote;\\r\\n};\\r\\n\\r\\nRemote.prototype.add_server = function (opts) {\\r\\n  var self = this;\\r\\n\\r\\n  var server = new Server(this, {\\r\\n    host   : opts.host || opts.websocket_ip,\\r\\n    port   : opts.port || opts.websocket_port,\\r\\n    secure : opts.secure || opts.websocket_ssl\\r\\n  });\\r\\n\\r\\n  function server_message(data) {\\r\\n    self._handle_message(data, server);\\r\\n  }\\r\\n\\r\\n  function server_connect() {\\r\\n    self._connection_count++;\\r\\n    self._set_state('online');\\r\\n    if (opts.primary || !self._primary_server) {\\r\\n      self._set_primary_server(server);\\r\\n    }\\r\\n    if (self._connection_count === self._servers.length) {\\r\\n      self.emit('ready');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function server_disconnect() {\\r\\n    self._connection_count--;\\r\\n    if (!self._connection_count) {\\r\\n      self._set_state('offline');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  server.on('message', server_message);\\r\\n  server.on('connect', server_connect);\\r\\n  server.on('disconnect', server_disconnect);\\r\\n\\r\\n  this._servers.push(server);\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n// Inform remote that the remote server is not comming back.\\r\\nRemote.prototype.server_fatal = function () {\\r\\n  this._server_fatal = true;\\r\\n};\\r\\n\\r\\n// Set the emitted state: 'online' or 'offline'\\r\\nRemote.prototype._set_state = function (state) {\\r\\n  this._trace('remote: set_state: %s', state);\\r\\n\\r\\n  if (this.state !== state) {\\r\\n    this.state = state;\\r\\n\\r\\n    this.emit('state', state);\\r\\n\\r\\n    switch (state) {\\r\\n      case 'online':\\r\\n        this._online_state = 'open';\\r\\n        this._connected    = true;\\r\\n        this.emit('connect');\\r\\n        this.emit('connected');\\r\\n        break;\\r\\n\\r\\n      case 'offline':\\r\\n        this._online_state = 'closed';\\r\\n        this._connected    = false;\\r\\n        this.emit('disconnect');\\r\\n        this.emit('disconnected');\\r\\n        break;\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nRemote.prototype.set_trace = function (trace) {\\r\\n  this.trace = trace === void(0) || trace;\\r\\n  return this;\\r\\n};\\r\\n\\r\\nRemote.prototype._trace = function() {\\r\\n  if (this.trace) {\\r\\n    utils.logObject.apply(utils, arguments);\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Connect to the Ripple network.\\r\\n */\\r\\nRemote.prototype.connect = function (online) {\\r\\n  if (!this._servers.length) {\\r\\n    throw new Error('No servers available.');\\r\\n  }\\r\\n\\r\\n  switch (typeof online) {\\r\\n    case 'undefined':\\r\\n      break;\\r\\n    case 'function':\\r\\n      this.once('connect', online);\\r\\n      break;\\r\\n    default:\\r\\n      // Downwards compatibility\\r\\n      if (!Boolean(online)) {\\r\\n        return this.disconnect();\\r\\n      }\\r\\n  }\\r\\n\\r\\n  var self = this;\\r\\n\\r\\n  ;(function next_server(i) {\\r\\n    var server = self._servers[i];\\r\\n    server.connect();\\r\\n    server._sid = ++i;\\r\\n\\r\\n    if (i < self._servers.length) {\\r\\n      setTimeout(function() {\\r\\n        next_server(i);\\r\\n      }, self._connection_offset);\\r\\n    }\\r\\n  })(0);\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Disconnect from the Ripple network.\\r\\n */\\r\\nRemote.prototype.disconnect = function (online) {\\r\\n  if (!this._servers.length) {\\r\\n    throw new Error('No servers available, not disconnecting');\\r\\n  }\\r\\n\\r\\n  this._servers.forEach(function(server) {\\r\\n    server.disconnect();\\r\\n  });\\r\\n\\r\\n  this._set_state('offline');\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n// It is possible for messages to be dispatched after the connection is closed.\\r\\nRemote.prototype._handle_message = function (message, server) {\\r\\n  var self = this;\\r\\n\\r\\n  try { message = JSON.parse(message); } catch(e) { }\\r\\n\\r\\n  var unexpected = typeof message !== 'object' || typeof message.type !== 'string';\\r\\n\\r\\n  if (unexpected) {\\r\\n    // Unexpected response from remote.\\r\\n    this.emit('error', new RippleError('remoteUnexpected', 'Unexpected response from remote'));\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  switch (message.type) {\\r\\n    case 'response':\\r\\n      // Handled by the server that sent the request\\r\\n      break;\\r\\n\\r\\n    case 'ledgerClosed':\\r\\n      // XXX If not trusted, need to verify we consider ledger closed.\\r\\n      // XXX Also need to consider a slow server or out of order response.\\r\\n      // XXX Be more defensive fields could be missing or of wrong type.\\r\\n      // YYY Might want to do some cache management.\\r\\n\\r\\n      this._ledger_time           = message.ledger_time;\\r\\n      this._ledger_hash           = message.ledger_hash;\\r\\n      this._ledger_current_index  = message.ledger_index + 1;\\r\\n\\r\\n      this.emit('ledger_closed', message, server);\\r\\n      break;\\r\\n\\r\\n    case 'transaction':\\r\\n      // To get these events, just subscribe to them. A subscribes and\\r\\n      // unsubscribes will be added as needed.\\r\\n      // XXX If not trusted, need proof.\\r\\n\\r\\n      // De-duplicate transactions that are immediately following each other\\r\\n      var hash = message.transaction.hash;\\r\\n\\r\\n      if (this._received_tx.hasOwnProperty(hash)) {\\r\\n        break;\\r\\n      }\\r\\n\\r\\n      this._received_tx[hash] = true;\\r\\n\\r\\n      this._trace('remote: tx: %s', message);\\r\\n\\r\\n      // Process metadata\\r\\n      message.mmeta = new Meta(message.meta);\\r\\n\\r\\n      // Pass the event on to any related Account objects\\r\\n      message.mmeta.getAffectedAccounts().forEach(function(account) {\\r\\n        account = self._accounts[account];\\r\\n        if (account) account.notify(message);\\r\\n      });\\r\\n\\r\\n      // Pass the event on to any related OrderBooks\\r\\n      message.mmeta.getAffectedBooks().forEach(function(book) {\\r\\n        book = self._books[book];\\r\\n        if (book) book.notify(message);\\r\\n      });\\r\\n\\r\\n      this.emit('transaction', message);\\r\\n      this.emit('transaction_all', message);\\r\\n      break;\\r\\n\\r\\n    case 'path_find':\\r\\n      // Pass the event to the currently open PathFind object\\r\\n      if (this._cur_path_find) {\\r\\n        this._cur_path_find.notify_update(message);\\r\\n      }\\r\\n\\r\\n      this.emit('path_find_all', message);\\r\\n      break;\\r\\n    case 'serverStatus':\\r\\n      self.emit('server_status', message);\\r\\n\\r\\n      var load_changed = message.hasOwnProperty('load_base')\\r\\n      && message.hasOwnProperty('load_factor')\\r\\n      && (message.load_base !== self._load_base || message.load_factor !== self._load_factor)\\r\\n      ;\\r\\n\\r\\n      if (load_changed) {\\r\\n        self._load_base   = message.load_base;\\r\\n        self._load_factor = message.load_factor;\\r\\n        var obj = {\\r\\n          load_base:    self._load_base,\\r\\n          load_factor:  self._load_factor,\\r\\n          fee_units:    self.fee_tx_unit()\\r\\n        }\\r\\n        self.emit('load', obj);\\r\\n        self.emit('load_changed', obj);\\r\\n      }\\r\\n      break;\\r\\n\\r\\n    // All other messages\\r\\n    default:\\r\\n      this._trace('remote: ' + message.type + ': %s', message);\\r\\n      this.emit('net_' + message.type, message);\\r\\n      break;\\r\\n  }\\r\\n};\\r\\n\\r\\nRemote.prototype.ledger_hash = function () {\\r\\n  return this._ledger_hash;\\r\\n};\\r\\n\\r\\nRemote.prototype._set_primary_server = function (server) {\\r\\n  if (this._primary_server) {\\r\\n    this._primary_server._primary = false;\\r\\n  }\\r\\n  this._primary_server            = server;\\r\\n  this._primary_server._primary   = true;\\r\\n};\\r\\n\\r\\nRemote.prototype._server_is_available  = function (server) {\\r\\n  return server && server._connected;\\r\\n};\\r\\n\\r\\nRemote.prototype._next_server = function () {\\r\\n  var result = null;\\r\\n\\r\\n  for (var i=0; i<this._servers.length; i++) {\\r\\n    var server = this._servers[i];\\r\\n    if (this._server_is_available(server)) {\\r\\n      result = server;\\r\\n      break;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return result;\\r\\n};\\r\\n\\r\\nRemote.prototype._get_server = function () {\\r\\n  var server;\\r\\n\\r\\n  if (this._server_is_available(this._primary_server)) {\\r\\n    server = this._primary_server;\\r\\n  } else {\\r\\n    server = this._next_server();\\r\\n    if (server) {\\r\\n      this._set_primary_server(server);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return server;\\r\\n};\\r\\n\\r\\n// Send a request.\\r\\n// <-> request: what to send, consumed.\\r\\nRemote.prototype.request = function (request) {\\r\\n  if (!this._servers.length) {\\r\\n    request.emit('error', new Error('No servers available'));\\r\\n  } else if (!this._connected) {\\r\\n    this.once('connect', this.request.bind(this, request));\\r\\n  } else if (request.server === null) {\\r\\n    this.emit('error', new Error('Server does not exist'));\\r\\n  } else {\\r\\n    var server = request.server || this._get_server();\\r\\n    if (server) {\\r\\n      server.request(request);\\r\\n    } else {\\r\\n      request.emit('error', new Error('No servers available'));\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nRemote.prototype.request_server_info = function(callback) {\\r\\n  return new Request(this, 'server_info').callback(callback);\\r\\n};\\r\\n\\r\\n// XXX This is a bad command. Some varients don't scale.\\r\\n// XXX Require the server to be trusted.\\r\\nRemote.prototype.request_ledger = function (ledger, opts, callback) {\\r\\n  //utils.assert(this.trusted);\\r\\n\\r\\n  var request = new Request(this, 'ledger');\\r\\n\\r\\n  if (ledger) {\\r\\n    // DEPRECATED: use .ledger_hash() or .ledger_index()\\r\\n    //console.log('request_ledger: ledger parameter is deprecated');\\r\\n    request.message.ledger  = ledger;\\r\\n  }\\r\\n\\r\\n  var props = [\\r\\n      'full'\\r\\n    , 'expand'\\r\\n    , 'transactions'\\r\\n    , 'accounts'\\r\\n  ];\\r\\n\\r\\n  switch (typeof opts) {\\r\\n    case 'object':\\r\\n      for (var key in opts) {\\r\\n        if (~props.indexOf(key)) {\\r\\n          request.message[key] = true;\\r\\n        }\\r\\n      }\\r\\n      break;\\r\\n\\r\\n    case 'function':\\r\\n      callback = opts;\\r\\n      opts = void(0);\\r\\n      break;\\r\\n\\r\\n    default:\\r\\n      //DEPRECATED\\r\\n      console.log('request_ledger: full parameter is deprecated');\\r\\n      request.message.full = true;\\r\\n      break;\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// Only for unit testing.\\r\\nRemote.prototype.request_ledger_hash = function (callback) {\\r\\n  //utils.assert(this.trusted);   // If not trusted, need to check proof.\\r\\n\\r\\n  return new Request(this, 'ledger_closed').callback(callback);\\r\\n};\\r\\n\\r\\n// .ledger()\\r\\n// .ledger_index()\\r\\nRemote.prototype.request_ledger_header = function (callback) {\\r\\n  return new Request(this, 'ledger_header').callback(callback);\\r\\n};\\r\\n\\r\\n// Get the current proposed ledger entry.  May be closed (and revised) at any time (even before returning).\\r\\n// Only for unit testing.\\r\\nRemote.prototype.request_ledger_current = function (callback) {\\r\\n  return new Request(this, 'ledger_current').callback(callback);\\r\\n};\\r\\n\\r\\n// --> type : the type of ledger entry.\\r\\n// .ledger()\\r\\n// .ledger_index()\\r\\n// .offer_id()\\r\\nRemote.prototype.request_ledger_entry = function (type, callback) {\\r\\n  //utils.assert(this.trusted);   // If not trusted, need to check proof, maybe talk packet protocol.\\r\\n\\r\\n  var self = this;\\r\\n  var request = new Request(this, 'ledger_entry');\\r\\n\\r\\n  // Transparent caching. When .request() is invoked, look in the Remote object for the result.\\r\\n  // If not found, listen, cache result, and emit it.\\r\\n  //\\r\\n  // Transparent caching:\\r\\n  if (type === 'account_root') {\\r\\n    request.request_default = request.request;\\r\\n\\r\\n    request.request = function () {                        // Intercept default request.\\r\\n      var bDefault  = true;\\r\\n      // .self = Remote\\r\\n      // this = Request\\r\\n\\r\\n      // console.log('request_ledger_entry: caught');\\r\\n\\r\\n      //if (self._ledger_hash) {\\r\\n        // A specific ledger is requested.\\r\\n        // XXX Add caching.\\r\\n        // else if (req.ledger_index)\\r\\n        // else if ('ripple_state' === request.type)         // YYY Could be cached per ledger.\\r\\n      //}\\r\\n\\r\\n      if (!self._ledger_hash && type === 'account_root') {\\r\\n        var cache = self.ledgers.current.account_root;\\r\\n\\r\\n        if (!cache) {\\r\\n          cache = self.ledgers.current.account_root = {};\\r\\n        }\\r\\n\\r\\n        var node = self.ledgers.current.account_root[request.message.account_root];\\r\\n\\r\\n        if (node) {\\r\\n          // Emulate fetch of ledger entry.\\r\\n          // console.log('request_ledger_entry: emulating');\\r\\n          // YYY Missing lots of fields.\\r\\n          request.emit('success', { node: node });\\r\\n          bDefault  = false;\\r\\n        } else { // Was not cached.\\r\\n          // XXX Only allow with trusted mode.  Must sync response with advance.\\r\\n          switch (type) {\\r\\n            case 'account_root':\\r\\n              request.once('success', function (message) {\\r\\n                // Cache node.\\r\\n                // console.log('request_ledger_entry: caching');\\r\\n                self.ledgers.current.account_root[message.node.Account] = message.node;\\r\\n              });\\r\\n              break;\\r\\n\\r\\n            default:\\r\\n              // This type not cached.\\r\\n              // console.log('request_ledger_entry: non-cached type');\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (bDefault) {\\r\\n        // console.log('request_ledger_entry: invoking');\\r\\n        request.request_default();\\r\\n      }\\r\\n    };\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// .accounts(accounts, realtime)\\r\\nRemote.prototype.request_subscribe = function (streams, callback) {\\r\\n  var request = new Request(this, 'subscribe');\\r\\n\\r\\n  if (streams) {\\r\\n    request.message.streams = Array.isArray(streams) ? streams : [ streams ];\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// .accounts(accounts, realtime)\\r\\nRemote.prototype.request_unsubscribe = function (streams, callback) {\\r\\n  var request = new Request(this, 'unsubscribe');\\r\\n\\r\\n  if (streams) {\\r\\n    request.message.streams = Array.isArray(streams) ? streams : [ streams ];\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// .ledger_choose()\\r\\n// .ledger_hash()\\r\\n// .ledger_index()\\r\\nRemote.prototype.request_transaction =\\r\\nRemote.prototype.request_transaction_entry = function (hash, ledger_hash, callback) {\\r\\n  //utils.assert(this.trusted);   // If not trusted, need to check proof, maybe talk packet protocol.\\r\\n  var request = new Request(this, 'transaction_entry');\\r\\n\\r\\n  request.tx_hash(hash);\\r\\n\\r\\n  switch (typeof ledger_hash) {\\r\\n    case 'string':\\r\\n      request.ledger_hash(ledger_hash);\\r\\n      break;\\r\\n    default:\\r\\n      request.ledger_index('validated');\\r\\n      callback = ledger_hash;\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// DEPRECATED: use request_transaction_entry\\r\\nRemote.prototype.request_tx = function (hash, callback) {\\r\\n  var request = new Request(this, 'tx');\\r\\n  request.message.transaction  = hash;\\r\\n  request.callback(callback);\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_account_info = function (accountID, callback) {\\r\\n  var request = new Request(this, 'account_info');\\r\\n  request.message.ident   = UInt160.json_rewrite(accountID);  // DEPRECATED\\r\\n  request.message.account = UInt160.json_rewrite(accountID);\\r\\n  request.callback(callback);\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.account_request = function(type, accountID, account_index, ledger, callback) {\\r\\n  if (typeof accountID === 'object') {\\r\\n    var options = accountID;\\r\\n    callback      = account_index;\\r\\n    ledger        = options.ledger;\\r\\n    account_index = options.account_index;\\r\\n    accoutID      = options.accountID;\\r\\n  }\\r\\n\\r\\n  var request = new Request(this, type);\\r\\n\\r\\n  request.message.account = UInt160.json_rewrite(accountID);\\r\\n\\r\\n  if (account_index) {\\r\\n    request.message.index = account_index;\\r\\n  }\\r\\n\\r\\n  request.ledger_choose(ledger);\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// --> account_index: sub_account index (optional)\\r\\n// --> current: true, for the current ledger.\\r\\nRemote.prototype.request_account_lines = function (accountID, account_index, ledger, callback) {\\r\\n  // XXX Does this require the server to be trusted?\\r\\n  //utils.assert(this.trusted);\\r\\n  var args = Array.prototype.slice.call(arguments);\\r\\n  args.unshift('account_lines');\\r\\n  return Remote.account_request.apply(this, args);\\r\\n};\\r\\n\\r\\n// --> account_index: sub_account index (optional)\\r\\n// --> current: true, for the current ledger.\\r\\nRemote.prototype.request_account_offers = function (accountID, account_index, ledger, callback) {\\r\\n  var args = Array.prototype.arguments.slice(arguments);\\r\\n  args.unshift('account_offers');\\r\\n  return Remote.account_request.apply(this, args);\\r\\n};\\r\\n\\r\\n/*\\r\\n  account: account,\\r\\n  ledger_index_min: ledger_index, // optional, defaults to -1 if ledger_index_max is specified.\\r\\n  ledger_index_max: ledger_index, // optional, defaults to -1 if ledger_index_min is specified.\\r\\n  binary: boolean,                // optional, defaults to false\\r\\n  count: boolean,                 // optional, defaults to false\\r\\n  descending: boolean,            // optional, defaults to false\\r\\n  offset: integer,                // optional, defaults to 0\\r\\n  limit: integer                  // optional\\r\\n*/\\r\\n\\r\\nRemote.prototype.request_account_tx = function (options, callback) {\\r\\n  // XXX Does this require the server to be trusted?\\r\\n  //utils.assert(this.trusted);\\r\\n\\r\\n  var request = new Request(this, 'account_tx');\\r\\n\\r\\n  var request_fields = [\\r\\n      'account'\\r\\n    , 'ledger_index_min'  //earliest\\r\\n    , 'ledger_index_max'  //latest\\r\\n    , 'binary'            //false\\r\\n    , 'count'             //false\\r\\n    , 'descending'        //false\\r\\n    , 'offset'            //0\\r\\n    , 'limit'\\r\\n\\r\\n    //extended account_tx\\r\\n    , 'forward'           //false\\r\\n    , 'marker'\\r\\n  ];\\r\\n\\r\\n  for (var key in options) {\\r\\n    if (~request_fields.indexOf(key)) {\\r\\n      request.message[key] = options[key];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Request the overall transaction history.\\r\\n *\\r\\n * Returns a list of transactions that happened recently on the network. The\\r\\n * default number of transactions to be returned is 20.\\r\\n */\\r\\nRemote.prototype.request_tx_history = function (start, callback) {\\r\\n  // XXX Does this require the server to be trusted?\\r\\n  //utils.assert(this.trusted);\\r\\n\\r\\n  var request = new Request(this, 'tx_history');\\r\\n\\r\\n  request.message.start = start;\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_book_offers = function (gets, pays, taker, callback) {\\r\\n  if (typeof gets === 'object') {\\r\\n    var options = gets;\\r\\n    taker = options.taker;\\r\\n    pays  = options.pays;\\r\\n    gets  = options.gets;\\r\\n  }\\r\\n\\r\\n  var request = new Request(this, 'book_offers');\\r\\n\\r\\n  request.message.taker_gets = {\\r\\n    currency: Currency.json_rewrite(gets.currency)\\r\\n  };\\r\\n\\r\\n  if (request.message.taker_gets.currency !== 'XRP') {\\r\\n    request.message.taker_gets.issuer = UInt160.json_rewrite(gets.issuer);\\r\\n  }\\r\\n\\r\\n  request.message.taker_pays = {\\r\\n    currency: Currency.json_rewrite(pays.currency)\\r\\n  };\\r\\n\\r\\n  if (request.message.taker_pays.currency !== 'XRP') {\\r\\n    request.message.taker_pays.issuer = UInt160.json_rewrite(pays.issuer);\\r\\n  }\\r\\n\\r\\n  request.message.taker = taker ? taker : UInt160.ACCOUNT_ONE;\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_wallet_accounts = function (seed, callback) {\\r\\n  utils.assert(this.trusted); // Don't send secrets.\\r\\n  var request = new Request(this, 'wallet_accounts');\\r\\n  request.message.seed = seed;\\r\\n  return request.callback(callback);\\r\\n};\\r\\n\\r\\nRemote.prototype.request_sign = function (secret, tx_json, callback) {\\r\\n  utils.assert(this.trusted); // Don't send secrets.\\r\\n  var request = new Request(this, 'sign');\\r\\n  request.message.secret  = secret;\\r\\n  request.message.tx_json = tx_json;\\r\\n  request.callback(callback);\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// Submit a transaction.\\r\\nRemote.prototype.request_submit = function (callback) {\\r\\n  return new Request(this, 'submit').callback(callback);\\r\\n};\\r\\n\\r\\n//\\r\\n// Higher level functions.\\r\\n//\\r\\n\\r\\n/**\\r\\n * Create a subscribe request with current subscriptions.\\r\\n *\\r\\n * Other classes can add their own subscriptions to this request by listening to\\r\\n * the server_subscribe event.\\r\\n *\\r\\n * This function will create and return the request, but not submit it.\\r\\n */\\r\\nRemote.prototype._server_prepare_subscribe = function (callback) {\\r\\n  var self  = this;\\r\\n\\r\\n  var feeds = [ 'ledger', 'server' ];\\r\\n\\r\\n  if (this._transaction_subs) {\\r\\n    feeds.push('transactions');\\r\\n  }\\r\\n\\r\\n  var request = this.request_subscribe(feeds);\\r\\n\\r\\n  request.once('success', function (message) {\\r\\n    self._stand_alone = !!message.stand_alone;\\r\\n    self._testnet     = !!message.testnet;\\r\\n\\r\\n    if (typeof message.random === 'string') {\\r\\n      var rand = message.random.match(/[0-9A-F]{8}/ig);\\r\\n      while (rand && rand.length) {\\r\\n        sjcl.random.addEntropy(parseInt(rand.pop(), 16));\\r\\n      }\\r\\n      self.emit('random', utils.hexToArray(message.random));\\r\\n    }\\r\\n\\r\\n    if (message.ledger_hash && message.ledger_index) {\\r\\n      self._ledger_time           = message.ledger_time;\\r\\n      self._ledger_hash           = message.ledger_hash;\\r\\n      self._ledger_current_index  = message.ledger_index+1;\\r\\n      self.emit('ledger_closed', message);\\r\\n    }\\r\\n\\r\\n    // FIXME Use this to estimate fee.\\r\\n    // XXX When we have multiple server support, most of this should be tracked\\r\\n    //     by the Server objects and then aggregated/interpreted by Remote.\\r\\n    self._load_base     = message.load_base || 256;\\r\\n    self._load_factor   = message.load_factor || 256;\\r\\n    self._fee_ref       = message.fee_ref;\\r\\n    self._fee_base      = message.fee_base;\\r\\n    self._reserve_base  = message.reserve_base;\\r\\n    self._reserve_inc   = message.reserve_inc;\\r\\n\\r\\n    self.emit('subscribed');\\r\\n  });\\r\\n\\r\\n  request.on('error', function (err) {\\r\\n    // XXX We need a better global error handling\\r\\n    //console.log(err);\\r\\n  });\\r\\n\\r\\n  self.emit('prepare_subscribe', request);\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  // XXX Could give error events, maybe even time out.\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// For unit testing: ask the remote to accept the current ledger.\\r\\n// - To be notified when the ledger is accepted, server_subscribe() then listen to 'ledger_hash' events.\\r\\n// A good way to be notified of the result of this is:\\r\\n//    remote.once('ledger_closed', function (ledger_closed, ledger_index) { ... } );\\r\\nRemote.prototype.ledger_accept = function (callback) {\\r\\n  if (this._stand_alone) {\\r\\n    var request = new Request(this, 'ledger_accept');\\r\\n    request.request();\\r\\n    request.callback(callback);\\r\\n  } else {\\r\\n    this.emit('error', new RippleError('notStandAlone'));\\r\\n  }\\r\\n  return this;\\r\\n};\\r\\n\\r\\n// Return a request to refresh the account balance.\\r\\nRemote.prototype.request_account_balance = function (account, ledger, callback) {\\r\\n  if (typeof account === 'object') {\\r\\n    callback = ledger;\\r\\n    ledger   = account.ledger;\\r\\n    account  = account.account;\\r\\n  }\\r\\n\\r\\n  var request = this.request_ledger_entry('account_root');\\r\\n  request.account_root(account);\\r\\n  request.ledger_choose(ledger);\\r\\n  request.once('success', function (message) {\\r\\n    request.emit('account_balance', Amount.from_json(message.node.Balance));\\r\\n  });\\r\\n  request.callback(callback, 'account_balance');\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// Return a request to return the account flags.\\r\\nRemote.prototype.request_account_flags = function (account, ledger, callback) {\\r\\n  if (typeof account === 'object') {\\r\\n    callback = ledger;\\r\\n    ledger   = account.ledger;\\r\\n    account  = account.account;\\r\\n  }\\r\\n\\r\\n  var request = this.request_ledger_entry('account_root');\\r\\n  request.account_root(account);\\r\\n  request.ledger_choose(ledger);\\r\\n  request.once('success', function (message) {\\r\\n    request.emit('account_flags', message.node.Flags);\\r\\n  });\\r\\n  request.callback(callback, 'account_flags');\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// Return a request to emit the owner count.\\r\\nRemote.prototype.request_owner_count = function (account, ledger, callback) {\\r\\n  if (typeof account === 'object') {\\r\\n    callback = ledger;\\r\\n    ledger   = account.ledger;\\r\\n    account  = account.account;\\r\\n  }\\r\\n\\r\\n  var request = this.request_ledger_entry('account_root');\\r\\n  request.account_root(account);\\r\\n  request.ledger_choose(ledger);\\r\\n  request.once('success', function (message) {\\r\\n    request.emit('owner_count', message.node.OwnerCount);\\r\\n  });\\r\\n  request.callback(callback, 'owner_count');\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.get_account = function(accountID) {\\r\\n  return this._accounts[UInt160.json_rewrite(accountID)];\\r\\n};\\r\\n\\r\\nRemote.prototype.add_account = function(accountID) {\\r\\n  var account = new Account(this, accountID);\\r\\n  if (account.is_valid()) {\\r\\n    this._accounts[accountID] = account;\\r\\n  }\\r\\n  return account;\\r\\n};\\r\\n\\r\\nRemote.prototype.account = function (accountID) {\\r\\n  var account = this.get_account(accountID);\\r\\n  return account ? account : this.add_account(accountID);\\r\\n};\\r\\n\\r\\nRemote.prototype.path_find = function (src_account, dst_account, dst_amount, src_currencies) {\\r\\n  if (typeof src_account === 'object') {\\r\\n    var options = src_account;\\r\\n    src_currencies = options.src_currencies;\\r\\n    dst_amount     = options.dst_amount;\\r\\n    dst_account    = options.dst_account;\\r\\n    src_account    = options.src_account;\\r\\n  }\\r\\n\\r\\n  var path_find = new PathFind(this, src_account, dst_account, dst_amount, src_currencies);\\r\\n\\r\\n  if (this._cur_path_find) {\\r\\n    this._cur_path_find.notify_superceded();\\r\\n  }\\r\\n\\r\\n  path_find.create();\\r\\n\\r\\n  this._cur_path_find = path_find;\\r\\n\\r\\n  return path_find;\\r\\n};\\r\\n\\r\\nRemote.prepare_trade = function(currency, issuer) {\\r\\n  return currency + (currency === 'XRP' ? '' : ('/' + issuer));\\r\\n};\\r\\n\\r\\nRemote.prototype.book = function (currency_gets, issuer_gets, currency_pays, issuer_pays) {\\r\\n  if (typeof currency_gets === 'object') {\\r\\n    var options = currency_gets;\\r\\n    issuer_pays   = options.issuer_pays;\\r\\n    currency_pays = options.currency_pays;\\r\\n    issuer_gets   = options.issuer_gets;\\r\\n    currency_gets = options.currency_gets;\\r\\n  }\\r\\n\\r\\n  var gets = Remote.prepare_trade(currency_gets, issuer_gets);\\r\\n  var pays = Remote.prepare_trade(currency_pays, issuer_pays);\\r\\n  var key = gets + ':' + pays;\\r\\n  var book;\\r\\n\\r\\n  if (!this._books.hasOwnProperty(key)) {\\r\\n    book = new OrderBook(this, currency_gets, issuer_gets, currency_pays, issuer_pays);\\r\\n    if (book.is_valid()) {\\r\\n      this._books[key] = book;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return this._books[key];\\r\\n};\\r\\n\\r\\n// Return the next account sequence if possible.\\r\\n// <-- undefined or Sequence\\r\\nRemote.prototype.account_seq = function (account, advance) {\\r\\n  var account      = UInt160.json_rewrite(account);\\r\\n  var account_info = this.accounts[account];\\r\\n  var seq;\\r\\n\\r\\n  if (account_info && account_info.seq) {\\r\\n    seq = account_info.seq;\\r\\n    var change = { ADVANCE: 1, REWIND: -1 }[advance.toUpperCase()] || 0;\\r\\n    account_info.seq += change;\\r\\n  }\\r\\n\\r\\n  return seq;\\r\\n};\\r\\n\\r\\nRemote.prototype.set_account_seq = function (account, seq) {\\r\\n  var account = UInt160.json_rewrite(account);\\r\\n\\r\\n  if (!this.accounts.hasOwnProperty(account)) {\\r\\n    this.accounts[account] = { };\\r\\n  }\\r\\n\\r\\n  this.accounts[account].seq = seq;\\r\\n}\\r\\n\\r\\n// Return a request to refresh accounts[account].seq.\\r\\nRemote.prototype.account_seq_cache = function (account, ledger, callback) {\\r\\n  if (typeof account === 'object') {\\r\\n    var options = account;\\r\\n    callback = ledger;\\r\\n    ledger   = options.ledger;\\r\\n    account  = options.account;\\r\\n  }\\r\\n\\r\\n  var self = this;\\r\\n\\r\\n  if (!this.accounts.hasOwnProperty(account)) {\\r\\n    this.accounts[account] = { };\\r\\n  }\\r\\n\\r\\n  var account_info = this.accounts[account];\\r\\n  var request      = account_info.caching_seq_request;\\r\\n\\r\\n  if (!request) {\\r\\n    // console.log('starting: %s', account);\\r\\n    request = this.request_ledger_entry('account_root');\\r\\n    request.account_root(account);\\r\\n    request.ledger_choose(ledger);\\r\\n\\r\\n    function account_root_success(message) {\\r\\n      delete account_info.caching_seq_request;\\r\\n\\r\\n      var seq = message.node.Sequence;\\r\\n      account_info.seq  = seq;\\r\\n\\r\\n      // console.log('caching: %s %d', account, seq);\\r\\n      // If the caller also waits for 'success', they might run before this.\\r\\n      request.emit('success_account_seq_cache', message);\\r\\n    }\\r\\n\\r\\n    function account_root_error(message) {\\r\\n      // console.log('error: %s', account);\\r\\n      delete account_info.caching_seq_request;\\r\\n\\r\\n      request.emit('error_account_seq_cache', message);\\r\\n    }\\r\\n\\r\\n    request.once('success', account_root_success);\\r\\n    request.once('error', account_root_error);\\r\\n\\r\\n    account_info.caching_seq_request = request;\\r\\n  }\\r\\n\\r\\n  request.callback(callback, 'success_account_seq_cache', 'error_account_seq_cache');\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// Mark an account's root node as dirty.\\r\\nRemote.prototype.dirty_account_root = function (account) {\\r\\n  var account = UInt160.json_rewrite(account);\\r\\n  delete this.ledgers.current.account_root[account];\\r\\n};\\r\\n\\r\\n// Store a secret - allows the Remote to automatically fill out auth information.\\r\\nRemote.prototype.set_secret = function (account, secret) {\\r\\n  this.secrets[account] = secret;\\r\\n};\\r\\n\\r\\n\\r\\n// Return a request to get a ripple balance.\\r\\n//\\r\\n// --> account: String\\r\\n// --> issuer: String\\r\\n// --> currency: String\\r\\n// --> current: bool : true = current ledger\\r\\n//\\r\\n// If does not exist: emit('error', 'error' : 'remoteError', 'remote' : { 'error' : 'entryNotFound' })\\r\\nRemote.prototype.request_ripple_balance = function (account, issuer, currency, ledger, callback) {\\r\\n  if (typeof account === 'object') {\\r\\n    var options = account;\\r\\n    callback = issuer;\\r\\n    ledger   = options.ledger;\\r\\n    currency = options.currency;\\r\\n    issuer   = options.issuer;\\r\\n    account  = options.account;\\r\\n  }\\r\\n\\r\\n  var request = this.request_ledger_entry('ripple_state'); // YYY Could be cached per ledger.\\r\\n\\r\\n  request.ripple_state(account, issuer, currency);\\r\\n  request.ledger_choose(ledger);\\r\\n  request.once('success', function(message) {\\r\\n    var node            = message.node;\\r\\n    var lowLimit        = Amount.from_json(node.LowLimit);\\r\\n    var highLimit       = Amount.from_json(node.HighLimit);\\r\\n    // The amount the low account holds of issuer.\\r\\n    var balance         = Amount.from_json(node.Balance);\\r\\n    // accountHigh implies: for account: balance is negated, highLimit is the limit set by account.\\r\\n    var accountHigh     = UInt160.from_json(account).equals(highLimit.issuer());\\r\\n\\r\\n    request.emit('ripple_state', {\\r\\n      account_balance     : ( accountHigh ? balance.negate() : balance.clone()).parse_issuer(account),\\r\\n      peer_balance        : (!accountHigh ? balance.negate() : balance.clone()).parse_issuer(issuer),\\r\\n\\r\\n      account_limit       : ( accountHigh ? highLimit : lowLimit).clone().parse_issuer(issuer),\\r\\n      peer_limit          : (!accountHigh ? highLimit : lowLimit).clone().parse_issuer(account),\\r\\n\\r\\n      account_quality_in  : ( accountHigh ? node.HighQualityIn : node.LowQualityIn),\\r\\n      peer_quality_in     : (!accountHigh ? node.HighQualityIn : node.LowQualityIn),\\r\\n\\r\\n      account_quality_out : ( accountHigh ? node.HighQualityOut : node.LowQualityOut),\\r\\n      peer_quality_out    : (!accountHigh ? node.HighQualityOut : node.LowQualityOut),\\r\\n    });\\r\\n  });\\r\\n\\r\\n  request.callback(callback, 'ripple_state');\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prepare_currencies = function(ci) {\\r\\n  var ci_new  = { };\\r\\n\\r\\n  if (ci.hasOwnProperty('issuer')) {\\r\\n    ci_new.issuer = UInt160.json_rewrite(ci.issuer);\\r\\n  }\\r\\n\\r\\n  if (ci.hasOwnProperty('currency')) {\\r\\n    ci_new.currency = Currency.json_rewrite(ci.currency);\\r\\n  }\\r\\n\\r\\n  return ci_new;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_ripple_path_find = function (src_account, dst_account, dst_amount, src_currencies, callback) {\\r\\n  if (typeof src_account === 'object') {\\r\\n    var options = src_account;\\r\\n    callback       = dst_account;\\r\\n    src_currencies = options.src_currencies;\\r\\n    dst_amount     = options.dst_amount;\\r\\n    dst_account    = options.dst_account;\\r\\n    src_account    = options.src_account;\\r\\n  }\\r\\n\\r\\n  var request = new Request(this, 'ripple_path_find');\\r\\n\\r\\n  request.message.source_account      = UInt160.json_rewrite(src_account);\\r\\n  request.message.destination_account = UInt160.json_rewrite(dst_account);\\r\\n  request.message.destination_amount  = Amount.json_rewrite(dst_amount);\\r\\n\\r\\n  if (src_currencies) {\\r\\n    request.message.source_currencies = src_currencies.map(Remote.prepare_currencies);\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_path_find_create = function (src_account, dst_account, dst_amount, src_currencies, callback) {\\r\\n  if (typeof src_account === 'object') {\\r\\n    var options = src_account;\\r\\n    callback       = dst_account;\\r\\n    src_currencies = options.src_currencies;\\r\\n    dst_amount     = options.dst_amount;\\r\\n    dst_account    = options.dst_account;\\r\\n    src_account    = options.src_account;\\r\\n  }\\r\\n\\r\\n  var request = new Request(this, 'path_find');\\r\\n\\r\\n  request.message.subcommand          = 'create';\\r\\n  request.message.source_account      = UInt160.json_rewrite(src_account);\\r\\n  request.message.destination_account = UInt160.json_rewrite(dst_account);\\r\\n  request.message.destination_amount  = Amount.json_rewrite(dst_amount);\\r\\n\\r\\n  if (src_currencies) {\\r\\n    request.message.source_currencies = src_currencies.map(Remote.prepare_currencies);\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_path_find_close = function () {\\r\\n  var request = new Request(this, 'path_find');\\r\\n  request.message.subcommand = 'close';\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_unl_list = function (callback) {\\r\\n  return new Request(this, 'unl_list').callback(callback);\\r\\n};\\r\\n\\r\\nRemote.prototype.request_unl_add = function (addr, comment, callback) {\\r\\n  var request = new Request(this, 'unl_add');\\r\\n\\r\\n  request.message.node = addr;\\r\\n\\r\\n  if (comment) {\\r\\n    request.message.comment = note;\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// --> node: <domain> | <public_key>\\r\\nRemote.prototype.request_unl_delete = function (node, callback) {\\r\\n  var request = new Request(this, 'unl_delete');\\r\\n  request.message.node = node;\\r\\n  request.callback(callback);\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_peers = function (callback) {\\r\\n  return new Request(this, 'peers').callback(callback);\\r\\n};\\r\\n\\r\\nRemote.prototype.request_connect = function (ip, port, callback) {\\r\\n  var request = new Request(this, 'connect');\\r\\n\\r\\n  request.message.ip = ip;\\r\\n\\r\\n  if (port) {\\r\\n    request.message.port = port;\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.transaction = function (source, destination, amount, callback) {\\r\\n  var tx = new Transaction(this);\\r\\n\\r\\n  if (arguments.length >= 3) {\\r\\n    tx = tx.payment(source, destination, amount);\\r\\n    if (typeof callback === 'function') {\\r\\n      tx.submit(callback);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return tx;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Calculate a transaction fee for a number of tx fee units.\\r\\n *\\r\\n * This takes into account the last known network and local load fees.\\r\\n *\\r\\n * @return {Amount} Final fee in XRP for specified number of fee units.\\r\\n */\\r\\nRemote.prototype.fee_tx = function (units) {\\r\\n  var fee_unit = this.fee_tx_unit();\\r\\n  return Amount.from_json(String(Math.ceil(units * fee_unit)));\\r\\n};\\r\\n\\r\\n/**\\r\\n * Get the current recommended transaction fee unit.\\r\\n *\\r\\n * Multiply this value with the number of fee units in order to calculate the\\r\\n * recommended fee for the transaction you are trying to submit.\\r\\n *\\r\\n * @return {Number} Recommended amount for one fee unit as float.\\r\\n */\\r\\nRemote.prototype.fee_tx_unit = function () {\\r\\n  var fee_unit = this._fee_base / this._fee_ref;\\r\\n\\r\\n  // Apply load fees\\r\\n  fee_unit *= this._load_factor / this._load_base;\\r\\n\\r\\n  // Apply fee cushion (a safety margin in case fees rise since we were last updated\\r\\n  fee_unit *= this.fee_cushion;\\r\\n\\r\\n  return fee_unit;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Get the current recommended reserve base.\\r\\n *\\r\\n * Returns the base reserve with load fees and safety margin applied.\\r\\n */\\r\\nRemote.prototype.reserve = function (owner_count) {\\r\\n  var reserve_base = Amount.from_json(String(this._reserve_base));\\r\\n  var reserve_inc  = Amount.from_json(String(this._reserve_inc));\\r\\n  var owner_count  = owner_count || 0;\\r\\n\\r\\n  if (owner_count < 0) {\\r\\n    throw new Error('Owner count must not be negative.');\\r\\n  }\\r\\n\\r\\n  return reserve_base.add(reserve_inc.product_human(owner_count));\\r\\n};\\r\\n\\r\\nRemote.prototype.ping = function(host, callback) {\\r\\n  var request = new Request(this, 'ping');\\r\\n\\r\\n  switch (typeof host) {\\r\\n    case 'function':\\r\\n      callback = host;\\r\\n      break;\\r\\n    case 'string':\\r\\n      request.set_server(host);\\r\\n      break;\\r\\n  }\\r\\n\\r\\n  var then = Date.now();\\r\\n\\r\\n  request.once('success', function() {\\r\\n    request.emit('pong', Date.now() - then);\\r\\n  });\\r\\n\\r\\n  request.callback(callback, 'pong');\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nexports.Remote = Remote;\\r\\n\\r\\n// vim:sw=2:sts=2:ts=8:et\\r\\n\\n\\n// WEBPACK FOOTER\\n// module.id = 1\\n// module.readableIdentifier = ./src/js/ripple/remote.js\\n//@ sourceURL=webpack-module:///./src/js/ripple/remote.js\");","\t129: \teval(\"var EventEmitter = require(27).EventEmitter;\\r\\nvar util         = require(28);\\r\\nvar utils        = require(9);\\r\\n\\r\\n/**\\r\\n *  @constructor Server\\r\\n *  @param  remote    The Remote object\\r\\n *  @param  opts       Configuration parameters.\\r\\n *\\r\\n *  Keys for cfg:\\r\\n *  url\\r\\n */ \\r\\n\\r\\nfunction Server(remote, opts) {\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  if (typeof opts !== 'object') {\\r\\n    throw new Error('Invalid server configuration.');\\r\\n  }\\r\\n\\r\\n  var self = this;\\r\\n\\r\\n  this._remote         = remote;\\r\\n  this._opts           = opts;\\r\\n  this._host           = opts.host;\\r\\n  this._port           = opts.port;\\r\\n  this._secure         = typeof opts.secure === 'boolean' ? opts.secure : true;\\r\\n  this._ws             = void(0);\\r\\n  this._connected      = false;\\r\\n  this._should_connect = false;\\r\\n  this._state          = void(0);\\r\\n  this._id             = 0;\\r\\n  this._retry          = 0;\\r\\n  this._requests       = { };\\r\\n\\r\\n  this._opts.url = (opts.secure ? 'wss://' : 'ws://') + opts.host + ':' + opts.port;\\r\\n\\r\\n  this.on('message', function(message) {\\r\\n    self._handle_message(message);\\r\\n  });\\r\\n\\r\\n  this.on('response_subscribe', function(message) {\\r\\n    self._handle_response_subscribe(message);\\r\\n  });\\r\\n}\\r\\n\\r\\nutil.inherits(Server, EventEmitter);\\r\\n\\r\\n/**\\r\\n * Server states that we will treat as the server being online.\\r\\n *\\r\\n * Our requirements are that the server can process transactions and notify\\r\\n * us of changes.\\r\\n */\\r\\nServer.online_states = [\\r\\n    'syncing'\\r\\n  , 'tracking'\\r\\n  , 'proposing'\\r\\n  , 'validating'\\r\\n  , 'full'\\r\\n];\\r\\n\\r\\nServer.prototype._is_online = function (status) {\\r\\n  return Server.online_states.indexOf(status) !== -1;\\r\\n};\\r\\n\\r\\nServer.prototype._set_state = function (state) {\\r\\n  if (state !== this._state) {\\r\\n    this._state = state;\\r\\n\\r\\n    this.emit('state', state);\\r\\n\\r\\n    switch (state) {\\r\\n      case 'online':\\r\\n        this._connected = true;\\r\\n        this.emit('connect');\\r\\n        break;\\r\\n      case 'offline':\\r\\n        this._connected = false;\\r\\n        this.emit('disconnect');\\r\\n        break;\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nServer.prototype._trace = function() {\\r\\n  if (this._remote.trace) {\\r\\n    utils.logObject.apply(utils, arguments);\\r\\n  }\\r\\n};\\r\\n\\r\\nServer.prototype._remote_address = function() {\\r\\n  try { var address = this._ws._socket.remoteAddress; } catch (e) { }\\r\\n  return address;\\r\\n};\\r\\n\\r\\n// This is the final interface between client code and a socket connection to a\\r\\n// `rippled` server. As such, this is a decent hook point to allow a WebSocket\\r\\n// interface conforming object to be used as a basis to mock rippled. This\\r\\n// avoids the need to bind a websocket server to a port and allows a more\\r\\n// synchronous style of code to represent a client <-> server message sequence.\\r\\n// We can also use this to log a message sequence to a buffer.\\r\\nServer.prototype.websocket_constructor = function () {\\r\\n  return require(26);\\r\\n};\\r\\n\\r\\nServer.prototype.connect = function () {\\r\\n  var self = this;\\r\\n\\r\\n  // We don't connect if we believe we're already connected. This means we have\\r\\n  // recently received a message from the server and the WebSocket has not\\r\\n  // reported any issues either. If we do fail to ping or the connection drops,\\r\\n  // we will automatically reconnect.\\r\\n  if (this._connected) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  this._trace('server: connect: %s', this._opts.url);\\r\\n\\r\\n  // Ensure any existing socket is given the command to close first.\\r\\n  if (this._ws) {\\r\\n    this._ws.close();\\r\\n  }\\r\\n\\r\\n  // We require this late, because websocket shims may be loaded after\\r\\n  // ripple-lib.\\r\\n  var WebSocket = this.websocket_constructor();\\r\\n  var ws = this._ws = new WebSocket(this._opts.url);\\r\\n\\r\\n  this._should_connect = true;\\r\\n\\r\\n  self.emit('connecting');\\r\\n\\r\\n  ws.onopen = function () {\\r\\n    // If we are no longer the active socket, simply ignore any event\\r\\n    if (ws === self._ws) {\\r\\n      self.emit('socket_open');\\r\\n      // Subscribe to events\\r\\n      var request = self._remote._server_prepare_subscribe();\\r\\n      self.request(request);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  ws.onerror = function (e) {\\r\\n    // If we are no longer the active socket, simply ignore any event\\r\\n    if (ws === self._ws) {\\r\\n      self._trace('server: onerror: %s', e.data || e);\\r\\n\\r\\n      // Most connection errors for WebSockets are conveyed as 'close' events with\\r\\n      // code 1006. This is done for security purposes and therefore unlikely to\\r\\n      // ever change.\\r\\n\\r\\n      // This means that this handler is hardly ever called in practice. If it is,\\r\\n      // it probably means the server's WebSocket implementation is corrupt, or\\r\\n      // the connection is somehow producing corrupt data.\\r\\n\\r\\n      // Most WebSocket applications simply log and ignore this error. Once we\\r\\n      // support for multiple servers, we may consider doing something like\\r\\n      // lowering this server's quality score.\\r\\n\\r\\n      // However, in Node.js this event may be triggered instead of the close\\r\\n      // event, so we need to handle it.\\r\\n      handleConnectionClose();\\r\\n    }\\r\\n  };\\r\\n\\r\\n  // Failure to open.\\r\\n  ws.onclose = function () {\\r\\n    // If we are no longer the active socket, simply ignore any event\\r\\n    if (ws === self._ws) {\\r\\n      self._trace('server: onclose: %s', ws.readyState);\\r\\n      handleConnectionClose();\\r\\n    }\\r\\n  };\\r\\n\\r\\n  function handleConnectionClose() {\\r\\n    self.emit('socket_close');\\r\\n    self._set_state('offline');\\r\\n\\r\\n    // Prevent additional events from this socket\\r\\n    ws.onopen = ws.onerror = ws.onclose = ws.onmessage = function () {};\\r\\n\\r\\n    // Should we be connected?\\r\\n    if (!self._should_connect) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Delay and retry.\\r\\n    self._retry      += 1;\\r\\n    self._retry_timer = setTimeout(function () {\\r\\n      self._trace('server: retry');\\r\\n      if (!self._should_connect) {\\r\\n        return;\\r\\n      }\\r\\n      self.connect();\\r\\n    }, self._retry < 40\\r\\n        ? 1000/20           // First, for 2 seconds: 20 times per second\\r\\n        : self._retry < 40+60\\r\\n          ? 1000            // Then, for 1 minute: once per second\\r\\n          : self._retry < 40+60+60\\r\\n            ? 10*1000       // Then, for 10 minutes: once every 10 seconds\\r\\n            : 30*1000);     // Then: once every 30 seconds\\r\\n  }\\r\\n\\r\\n  ws.onmessage = function (msg) {\\r\\n    self.emit('message', msg.data);\\r\\n  };\\r\\n};\\r\\n\\r\\nServer.prototype.disconnect = function () {\\r\\n  this._should_connect = false;\\r\\n  this._set_state('offline');\\r\\n  if (this._ws) {\\r\\n    this._ws.close();\\r\\n  }\\r\\n};\\r\\n\\r\\nServer.prototype.send_message = function (message) {\\r\\n  if (this._ws) {\\r\\n    this._ws.send(JSON.stringify(message));\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Submit a Request object to this server.\\r\\n */\\r\\nServer.prototype.request = function (request) {\\r\\n  var self  = this;\\r\\n\\r\\n  // Only bother if we are still connected.\\r\\n  if (this._ws) {\\r\\n    request.server     = this;\\r\\n    request.message.id = this._id;\\r\\n\\r\\n    this._requests[request.message.id] = request;\\r\\n\\r\\n    // Advance message ID\\r\\n    this._id++;\\r\\n\\r\\n    var is_connected = this._connected || (request.message.command === 'subscribe' && this._ws.readyState === 1);\\r\\n    \\r\\n    if (is_connected) {\\r\\n      this._trace('server: request: %s', request.message);\\r\\n      this.send_message(request.message);\\r\\n    } else {\\r\\n      // XXX There are many ways to make this smarter.\\r\\n      function server_reconnected() {\\r\\n        self._trace('server: request: %s', request.message);\\r\\n        self.send_message(request.message);\\r\\n      }\\r\\n      this.once('connect', server_reconnected);\\r\\n    }\\r\\n  } else {\\r\\n    this._trace('server: request: DROPPING: %s', request.message);\\r\\n  }\\r\\n};\\r\\n\\r\\nServer.prototype._handle_message = function (message) {\\r\\n  var self = this;\\r\\n\\r\\n  try { message = JSON.parse(message); } catch(e) { }\\r\\n\\r\\n  var unexpected = typeof message !== 'object' || typeof message.type !== 'string';\\r\\n\\r\\n  if (unexpected) {\\r\\n    return; \\r\\n  }\\r\\n\\r\\n  switch (message.type) {\\r\\n    case 'response':\\r\\n      // A response to a request.\\r\\n      var request = self._requests[message.id];\\r\\n      delete self._requests[message.id];\\r\\n\\r\\n      if (!request) {\\r\\n        this._trace('server: UNEXPECTED: %s', message);\\r\\n      } else if ('success' === message.status) {\\r\\n        this._trace('server: response: %s', message);\\r\\n\\r\\n        request.emit('success', message.result);\\r\\n\\r\\n        [ self, self._remote ].forEach(function(emitter) {\\r\\n          emitter.emit('response_' + request.message.command, message.result, request, message);\\r\\n        });\\r\\n      } else if (message.error) {\\r\\n        this._trace('server: error: %s', message);\\r\\n\\r\\n        request.emit('error', {\\r\\n          error         : 'remoteError',\\r\\n          error_message : 'Remote reported an error.',\\r\\n          remote        : message\\r\\n        });\\r\\n      }\\r\\n      break;\\r\\n\\r\\n    case 'path_find':\\r\\n      if (self._remote.trace) utils.logObject('server: path_find: %s', message);\\r\\n      break;\\r\\n\\r\\n    case 'serverStatus':\\r\\n      // This message is only received when online. As we are connected, it is the definative final state.\\r\\n      this._set_state(this._is_online(message.server_status) ? 'online' : 'offline');\\r\\n      break;\\r\\n  }\\r\\n}\\r\\n\\r\\nServer.prototype._handle_response_subscribe = function (message) {\\r\\n  this._server_status = message.server_status;\\r\\n  if (this._is_online(message.server_status)) {\\r\\n    this._set_state('online');\\r\\n  }\\r\\n}\\r\\n\\r\\nexports.Server = Server;\\r\\n\\r\\n// vim:sw=2:sts=2:ts=8:et\\r\\n\\n\\n// WEBPACK FOOTER\\n// module.id = 11\\n// module.readableIdentifier = ./src/js/ripple/server.js\\n//@ sourceURL=webpack-module:///./src/js/ripple/server.js\");","\t234: \teval(\"// If there is no WebSocket, try MozWebSocket (support for some old browsers)\\r\\ntry {\\r\\n  module.exports = WebSocket\\r\\n} catch(err) {\\r\\n  module.exports = MozWebSocket\\r\\n}\\n\\n// WEBPACK FOOTER\\n// module.id = 26\\n// module.readableIdentifier = ./web_modules/ws.js\\n//@ sourceURL=webpack-module:///./web_modules/ws.js\");","",""]},{"start":{"row":7,"column":0},"end":{"row":41,"column":0},"action":"insert","lines":["/basicincome_co/dependencies/ripple-0.9.2.js:","\t118: \t//   http://www.w3.org/TR/websockets/#the-websocket-interface","\t123: \t// private WebSocket interfaces. The JavaScript class for the peer protocol","\t156: \t *    This implementation uses WebSockets.","\t304: \t  if (!opts.hasOwnProperty('servers') && opts.hasOwnProperty('websocket_ip')) {","\t307: \t        host:     opts.websocket_ip,","\t308: \t        port:     opts.websocket_port,","\t309: \t        secure:   opts.websocket_ssl,","\t8804: \t * `rippled` server. As such, this is a decent hook point to allow a WebSocket","\t8806: \t * avoids the need to bind a websocket server to a port and allows a more","\t8813: \tServer.websocketConstructor = function() {","\t8814: \t  // We require this late, because websocket shims may be loaded after","\t8951: \t * Disconnect from rippled WebSocket server","\t8980: \t * Reconnect to rippled WebSocket server","\t9005: \t * Connect to rippled WebSocket server and subscribe to events that are","\t9015: \t  var WebSocket = Server.websocketConstructor();","\t9017: \t  if (!WebSocket) {","\t9018: \t    throw new Error('No websocket support detected!');","\t9022: \t  // recently received a message from the server and the WebSocket has not","\t9038: \t  var ws = this._ws = new WebSocket(this._opts.url);","\t9064: \t      // Most connection errors for WebSockets are conveyed as 'close' events with","\t9069: \t      // it probably means the server's WebSocket implementation is corrupt, or","\t9072: \t      // Most WebSocket applications simply log and ignore this error. Once we","\t9151: \t * Handle incoming messages from rippled WebSocket server","\t9335: \t * Send JSON message to rippled WebSocket server","\t9354: \t * rippled WebSocket server","\t25505: \t * WebSocket constructor.","\t25508: \tvar WebSocket = global.WebSocket || global.MozWebSocket;","\t25514: \tmodule.exports = WebSocket ? ws : null;","\t25517: \t * WebSocket constructor.","\t25532: \t    instance = new WebSocket(uri, protocols);","\t25534: \t    instance = new WebSocket(uri);","\t25539: \tif (WebSocket) ws.prototype = WebSocket.prototype;","",""]},{"start":{"row":41,"column":0},"end":{"row":58,"column":0},"action":"insert","lines":["/fireworks/index.html:","\t69:     // WEBSOCKET OPTIONS","\t72:         \"websocket_ip\" : \"s1.ripple.com\",","\t73:         \"websocket_port\" : 443,","\t74:         \"websocket_ssl\" : true","\t80:     function startWebsocket(callback) {","\t83:       var url = (Options.server.websocket_ssl ? 'wss://' : 'ws://')","\t84:       + Options.server.websocket_ip + ':'","\t85:       + Options.server.websocket_port;","\t87:       server.socket = new WebSocket(url);","\t90:         console.log(\"opened websocket\");","\t105:         console.log(\"disconnected from websocket; connect after 5 seconds\");","\t106:         setTimeout(startWebsocket, 1000 * 5);","\t112:       startWebsocket();","\t116:       var hasWebSocket = !ONLINE || ('WebSocket' in window && window.WebSocket.CLOSING === 2);","\t118:       if (hasWebSocket && hasWebGL) {","",""]},{"start":{"row":58,"column":0},"end":{"row":59,"column":0},"action":"insert","lines":["Found 79 matches in 3 files ",""]},{"start":{"row":59,"column":0},"end":{"row":60,"column":0},"action":"insert","lines":["",""]},{"start":{"row":0,"column":48},"end":{"row":0,"column":78},"action":"insert","lines":[" (Found 79 matches in 3 files)"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":0,"column":9},"action":"remove","lines":["Searching"]},{"start":{"row":0,"column":1},"end":{"row":60,"column":0},"action":"remove","lines":["for \u0001WebSocket\u0001 in\u0001the entire project\u0001 (Found 79 matches in 3 files)","","/ripple-0.7.201-debug.js:","\t59: \teval(\"// Remote access to a server.\\r\\n// - We never send binary data.\\r\\n// - We use the W3C interface for node and browser compatibility:\\r\\n//   http://www.w3.org/TR/websockets/#the-websocket-interface\\r\\n//\\r\\n// This class is intended for both browser and node.js use.\\r\\n//\\r\\n// This class is designed to work via peer protocol via either the public or\\r\\n// private websocket interfaces.  The JavaScript class for the peer protocol\\r\\n// has not yet been implemented. However, this class has been designed for it\\r\\n// to be a very simple drop option.\\r\\n//\\r\\n// YYY Will later provide js/network.js which will transparently use multiple\\r\\n// instances of this class for network access.\\r\\n//\\r\\n\\r\\n// npm\\r\\nvar EventEmitter = require(27).EventEmitter;\\r\\nvar util         = require(28);\\r\\n\\r\\nvar Request      = require(14).Request;\\r\\nvar Server       = require(11).Server;\\r\\nvar Amount       = require(2).Amount;\\r\\nvar Currency     = require(3).Currency;\\r\\nvar UInt160      = require(15).UInt160;\\r\\nvar Transaction  = require(5).Transaction;\\r\\nvar Account      = require(16).Account;\\r\\nvar Meta         = require(6).Meta;\\r\\nvar OrderBook    = require(17).OrderBook;\\r\\nvar PathFind     = require(18).PathFind;\\r\\nvar RippleError  = require(19).RippleError;\\r\\n\\r\\nvar utils        = require(9);\\r\\nvar config       = require(12);\\r\\nvar sjcl         = require(10);\\r\\n\\r\\n/**\\r\\n    Interface to manage the connection to a Ripple server.\\r\\n\\r\\n    This implementation uses WebSockets.\\r\\n\\r\\n    Keys for opts:\\r\\n\\r\\n      trace\\r\\n      max_listeners      : Set maxListeners for remote; prevents EventEmitter warnings\\r\\n      connection_offset  : Connect to remote servers on supplied interval (in seconds)\\r\\n      trusted            : truthy, if remote is trusted\\r\\n      max_fee            : Maximum acceptable transaction fee\\r\\n      fee_cushion        : Extra fee multiplier to account for async fee changes.\\r\\n      servers            : Array of server objects with the following form\\r\\n\\r\\n         { \\r\\n              host:    <string>\\r\\n            , port:    <number>\\r\\n            , secure:  <boolean>\\r\\n         }\\r\\n\\r\\n    Events:\\r\\n      'connect'\\r\\n      'connected' (DEPRECATED)\\r\\n      'disconnect'\\r\\n      'disconnected' (DEPRECATED)\\r\\n      'state':\\r\\n      - 'online'        : Connected and subscribed.\\r\\n      - 'offline'       : Not subscribed or not connected.\\r\\n      'subscribed'      : This indicates stand-alone is available.\\r\\n\\r\\n    Server events:\\r\\n      'ledger_closed'   : A good indicate of ready to serve.\\r\\n      'transaction'     : Transactions we receive based on current subscriptions.\\r\\n      'transaction_all' : Listening triggers a subscribe to all transactions\\r\\n                          globally in the network.\\r\\n\\r\\n    @param opts      Connection options.\\r\\n    @param trace\\r\\n*/\\r\\n\\r\\nfunction Remote(opts, trace) {\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  var self  = this;\\r\\n\\r\\n  this.trusted               = Boolean(opts.trusted);\\r\\n  this.local_sequence        = Boolean(opts.local_sequence); // Locally track sequence numbers\\r\\n  this.local_fee             = (typeof opts.local_fee === 'undefined') ? true : Boolean(opts.local_fee); // Locally set fees\\r\\n  this.local_signing         = (typeof opts.local_signing === 'undefined') ? true : Boolean(opts.local_signing);\\r\\n  this.fee_cushion           = (typeof opts.fee_cushion === 'undefined') ? 1.5 : Number(opts.fee_cushion);\\r\\n  this.max_fee               = (typeof opts.max_fee === 'undefined') ? Infinity : Number(opts.max_fee);\\r\\n  this.id                    = 0;\\r\\n  this.trace                 = Boolean(opts.trace);\\r\\n  this._server_fatal         = false; // True, if we know server exited.\\r\\n  this._ledger_current_index = void(0);\\r\\n  this._ledger_hash          = void(0);\\r\\n  this._ledger_time          = void(0);\\r\\n  this._stand_alone          = void(0);\\r\\n  this._testnet              = void(0);\\r\\n  this._transaction_subs     = 0;\\r\\n  this.online_target         = false;\\r\\n  this._online_state         = 'closed'; // 'open', 'closed', 'connecting', 'closing'\\r\\n  this.state                 = 'offline'; // 'online', 'offline'\\r\\n  this.retry_timer           = void(0);\\r\\n  this.retry                 = void(0);\\r\\n\\r\\n  this._load_base            = 256;\\r\\n  this._load_factor          = 256;\\r\\n  this._fee_ref              = 10;\\r\\n  this._fee_base             = 10;\\r\\n  this._reserve_base         = void(0);\\r\\n  this._reserve_inc          = void(0);\\r\\n  this._connection_count     = 0;\\r\\n  this._connected            = false;\\r\\n  this._connection_offset    = 1000 * (Number(opts.connection_offset) || 5);\\r\\n  this._submission_timeout   = 1000 * (Number(opts.submission_timeout) || 10);\\r\\n\\r\\n  this._received_tx          = { };\\r\\n  this._cur_path_find        = null;\\r\\n\\r\\n  // Local signing implies local fees and sequences\\r\\n  if (this.local_signing) {\\r\\n    this.local_sequence = true;\\r\\n    this.local_fee      = true;\\r\\n  }\\r\\n\\r\\n  this._servers        = [ ];\\r\\n  this._primary_server = void(0);\\r\\n\\r\\n  // Cache information for accounts.\\r\\n  // DEPRECATED, will be removed\\r\\n  this.accounts = {\\r\\n    // Consider sequence numbers stable if you know you're not generating bad transactions.\\r\\n    // Otherwise, clear it to have it automatically refreshed from the network.\\r\\n\\r\\n    // account : { seq : __ }\\r\\n  };\\r\\n\\r\\n  // Account objects by AccountId.\\r\\n  this._accounts = { };\\r\\n\\r\\n  // OrderBook objects\\r\\n  this._books = { };\\r\\n\\r\\n  // Secrets that we know about.\\r\\n  this.secrets = {\\r\\n    // Secrets can be set by calling set_secret(account, secret).\\r\\n\\r\\n    // account : secret\\r\\n  };\\r\\n\\r\\n  // Cache for various ledgers.\\r\\n  // XXX Clear when ledger advances.\\r\\n  this.ledgers = {\\r\\n    current : {\\r\\n      account_root : {}\\r\\n    }\\r\\n  };\\r\\n\\r\\n  // Fallback for previous API\\r\\n  if (!opts.hasOwnProperty('servers')) {\\r\\n    opts.servers = [ \\r\\n      {\\r\\n        host:     opts.websocket_ip,\\r\\n        port:     opts.websocket_port,\\r\\n        secure:   opts.websocket_ssl,\\r\\n        trusted:  opts.trusted\\r\\n      }\\r\\n    ];\\r\\n  }\\r\\n\\r\\n  opts.servers.forEach(function(server) {\\r\\n    var pool = Number(server.pool) || 1;\\r\\n    while (pool--) { self.add_server(server); };\\r\\n  });\\r\\n\\r\\n  // This is used to remove Node EventEmitter warnings\\r\\n  var maxListeners = opts.maxListeners || opts.max_listeners || 0;\\r\\n  this._servers.concat(this).forEach(function(emitter) {\\r\\n    emitter.setMaxListeners(maxListeners);\\r\\n  });\\r\\n\\r\\n  function listener_added(type, listener) {\\r\\n    if (type === 'transaction_all') {\\r\\n      if (!self._transaction_subs && self._connected) {\\r\\n        self.request_subscribe('transactions').request();\\r\\n      }\\r\\n      self._transaction_subs += 1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function listener_removed(type, listener) {\\r\\n    if (type === 'transaction_all') {\\r\\n      self._transaction_subs -= 1;\\r\\n      if (!self._transaction_subs && self._connected) {\\r\\n        self.request_unsubscribe('transactions').request();\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  this.on('newListener', listener_added);\\r\\n  this.on('removeListener', listener_removed);\\r\\n}\\r\\n\\r\\nutil.inherits(Remote, EventEmitter);\\r\\n\\r\\n// Flags for ledger entries. In support of account_root().\\r\\nRemote.flags = {\\r\\n  account_root : {\\r\\n    PasswordSpent:   0x00010000,\\r\\n    RequireDestTag:  0x00020000,\\r\\n    RequireAuth:     0x00040000,\\r\\n    DisallowXRP:     0x00080000\\r\\n  }\\r\\n};\\r\\n\\r\\nfunction isTemMalformed(engine_result_code) {\\r\\n  return (engine_result_code >= -299 && engine_result_code <  199);\\r\\n};\\r\\n\\r\\nfunction isTefFailure(engine_result_code) {\\r\\n  return (engine_result_code >= -299 && engine_result_code <  199);\\r\\n};\\r\\n\\r\\nRemote.from_config = function (obj, trace) {\\r\\n  var serverConfig = typeof obj === 'string' ? config.servers[obj] : obj;\\r\\n\\r\\n  var remote = new Remote(serverConfig, trace);\\r\\n\\r\\n  function initialize_account(account) {\\r\\n    var accountInfo = config.accounts[account];\\r\\n    if (typeof accountInfo === 'object') {\\r\\n      if (accountInfo.secret) {\\r\\n        // Index by nickname ...\\r\\n        remote.set_secret(account, accountInfo.secret);\\r\\n        // ... and by account ID\\r\\n        remote.set_secret(accountInfo.account, accountInfo.secret);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (typeof config.accounts === 'object') {\\r\\n    for (var account in config.accounts) {\\r\\n      initialize_account(account);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return remote;\\r\\n};\\r\\n\\r\\nRemote.create_remote = function(options, callback) {\\r\\n  var remote = Remote.from_config(options);\\r\\n  remote.connect(callback);\\r\\n  return remote;\\r\\n};\\r\\n\\r\\nRemote.prototype.add_server = function (opts) {\\r\\n  var self = this;\\r\\n\\r\\n  var server = new Server(this, {\\r\\n    host   : opts.host || opts.websocket_ip,\\r\\n    port   : opts.port || opts.websocket_port,\\r\\n    secure : opts.secure || opts.websocket_ssl\\r\\n  });\\r\\n\\r\\n  function server_message(data) {\\r\\n    self._handle_message(data, server);\\r\\n  }\\r\\n\\r\\n  function server_connect() {\\r\\n    self._connection_count++;\\r\\n    self._set_state('online');\\r\\n    if (opts.primary || !self._primary_server) {\\r\\n      self._set_primary_server(server);\\r\\n    }\\r\\n    if (self._connection_count === self._servers.length) {\\r\\n      self.emit('ready');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function server_disconnect() {\\r\\n    self._connection_count--;\\r\\n    if (!self._connection_count) {\\r\\n      self._set_state('offline');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  server.on('message', server_message);\\r\\n  server.on('connect', server_connect);\\r\\n  server.on('disconnect', server_disconnect);\\r\\n\\r\\n  this._servers.push(server);\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n// Inform remote that the remote server is not comming back.\\r\\nRemote.prototype.server_fatal = function () {\\r\\n  this._server_fatal = true;\\r\\n};\\r\\n\\r\\n// Set the emitted state: 'online' or 'offline'\\r\\nRemote.prototype._set_state = function (state) {\\r\\n  this._trace('remote: set_state: %s', state);\\r\\n\\r\\n  if (this.state !== state) {\\r\\n    this.state = state;\\r\\n\\r\\n    this.emit('state', state);\\r\\n\\r\\n    switch (state) {\\r\\n      case 'online':\\r\\n        this._online_state = 'open';\\r\\n        this._connected    = true;\\r\\n        this.emit('connect');\\r\\n        this.emit('connected');\\r\\n        break;\\r\\n\\r\\n      case 'offline':\\r\\n        this._online_state = 'closed';\\r\\n        this._connected    = false;\\r\\n        this.emit('disconnect');\\r\\n        this.emit('disconnected');\\r\\n        break;\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nRemote.prototype.set_trace = function (trace) {\\r\\n  this.trace = trace === void(0) || trace;\\r\\n  return this;\\r\\n};\\r\\n\\r\\nRemote.prototype._trace = function() {\\r\\n  if (this.trace) {\\r\\n    utils.logObject.apply(utils, arguments);\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Connect to the Ripple network.\\r\\n */\\r\\nRemote.prototype.connect = function (online) {\\r\\n  if (!this._servers.length) {\\r\\n    throw new Error('No servers available.');\\r\\n  }\\r\\n\\r\\n  switch (typeof online) {\\r\\n    case 'undefined':\\r\\n      break;\\r\\n    case 'function':\\r\\n      this.once('connect', online);\\r\\n      break;\\r\\n    default:\\r\\n      // Downwards compatibility\\r\\n      if (!Boolean(online)) {\\r\\n        return this.disconnect();\\r\\n      }\\r\\n  }\\r\\n\\r\\n  var self = this;\\r\\n\\r\\n  ;(function next_server(i) {\\r\\n    var server = self._servers[i];\\r\\n    server.connect();\\r\\n    server._sid = ++i;\\r\\n\\r\\n    if (i < self._servers.length) {\\r\\n      setTimeout(function() {\\r\\n        next_server(i);\\r\\n      }, self._connection_offset);\\r\\n    }\\r\\n  })(0);\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Disconnect from the Ripple network.\\r\\n */\\r\\nRemote.prototype.disconnect = function (online) {\\r\\n  if (!this._servers.length) {\\r\\n    throw new Error('No servers available, not disconnecting');\\r\\n  }\\r\\n\\r\\n  this._servers.forEach(function(server) {\\r\\n    server.disconnect();\\r\\n  });\\r\\n\\r\\n  this._set_state('offline');\\r\\n\\r\\n  return this;\\r\\n};\\r\\n\\r\\n// It is possible for messages to be dispatched after the connection is closed.\\r\\nRemote.prototype._handle_message = function (message, server) {\\r\\n  var self = this;\\r\\n\\r\\n  try { message = JSON.parse(message); } catch(e) { }\\r\\n\\r\\n  var unexpected = typeof message !== 'object' || typeof message.type !== 'string';\\r\\n\\r\\n  if (unexpected) {\\r\\n    // Unexpected response from remote.\\r\\n    this.emit('error', new RippleError('remoteUnexpected', 'Unexpected response from remote'));\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  switch (message.type) {\\r\\n    case 'response':\\r\\n      // Handled by the server that sent the request\\r\\n      break;\\r\\n\\r\\n    case 'ledgerClosed':\\r\\n      // XXX If not trusted, need to verify we consider ledger closed.\\r\\n      // XXX Also need to consider a slow server or out of order response.\\r\\n      // XXX Be more defensive fields could be missing or of wrong type.\\r\\n      // YYY Might want to do some cache management.\\r\\n\\r\\n      this._ledger_time           = message.ledger_time;\\r\\n      this._ledger_hash           = message.ledger_hash;\\r\\n      this._ledger_current_index  = message.ledger_index + 1;\\r\\n\\r\\n      this.emit('ledger_closed', message, server);\\r\\n      break;\\r\\n\\r\\n    case 'transaction':\\r\\n      // To get these events, just subscribe to them. A subscribes and\\r\\n      // unsubscribes will be added as needed.\\r\\n      // XXX If not trusted, need proof.\\r\\n\\r\\n      // De-duplicate transactions that are immediately following each other\\r\\n      var hash = message.transaction.hash;\\r\\n\\r\\n      if (this._received_tx.hasOwnProperty(hash)) {\\r\\n        break;\\r\\n      }\\r\\n\\r\\n      this._received_tx[hash] = true;\\r\\n\\r\\n      this._trace('remote: tx: %s', message);\\r\\n\\r\\n      // Process metadata\\r\\n      message.mmeta = new Meta(message.meta);\\r\\n\\r\\n      // Pass the event on to any related Account objects\\r\\n      message.mmeta.getAffectedAccounts().forEach(function(account) {\\r\\n        account = self._accounts[account];\\r\\n        if (account) account.notify(message);\\r\\n      });\\r\\n\\r\\n      // Pass the event on to any related OrderBooks\\r\\n      message.mmeta.getAffectedBooks().forEach(function(book) {\\r\\n        book = self._books[book];\\r\\n        if (book) book.notify(message);\\r\\n      });\\r\\n\\r\\n      this.emit('transaction', message);\\r\\n      this.emit('transaction_all', message);\\r\\n      break;\\r\\n\\r\\n    case 'path_find':\\r\\n      // Pass the event to the currently open PathFind object\\r\\n      if (this._cur_path_find) {\\r\\n        this._cur_path_find.notify_update(message);\\r\\n      }\\r\\n\\r\\n      this.emit('path_find_all', message);\\r\\n      break;\\r\\n    case 'serverStatus':\\r\\n      self.emit('server_status', message);\\r\\n\\r\\n      var load_changed = message.hasOwnProperty('load_base')\\r\\n      && message.hasOwnProperty('load_factor')\\r\\n      && (message.load_base !== self._load_base || message.load_factor !== self._load_factor)\\r\\n      ;\\r\\n\\r\\n      if (load_changed) {\\r\\n        self._load_base   = message.load_base;\\r\\n        self._load_factor = message.load_factor;\\r\\n        var obj = {\\r\\n          load_base:    self._load_base,\\r\\n          load_factor:  self._load_factor,\\r\\n          fee_units:    self.fee_tx_unit()\\r\\n        }\\r\\n        self.emit('load', obj);\\r\\n        self.emit('load_changed', obj);\\r\\n      }\\r\\n      break;\\r\\n\\r\\n    // All other messages\\r\\n    default:\\r\\n      this._trace('remote: ' + message.type + ': %s', message);\\r\\n      this.emit('net_' + message.type, message);\\r\\n      break;\\r\\n  }\\r\\n};\\r\\n\\r\\nRemote.prototype.ledger_hash = function () {\\r\\n  return this._ledger_hash;\\r\\n};\\r\\n\\r\\nRemote.prototype._set_primary_server = function (server) {\\r\\n  if (this._primary_server) {\\r\\n    this._primary_server._primary = false;\\r\\n  }\\r\\n  this._primary_server            = server;\\r\\n  this._primary_server._primary   = true;\\r\\n};\\r\\n\\r\\nRemote.prototype._server_is_available  = function (server) {\\r\\n  return server && server._connected;\\r\\n};\\r\\n\\r\\nRemote.prototype._next_server = function () {\\r\\n  var result = null;\\r\\n\\r\\n  for (var i=0; i<this._servers.length; i++) {\\r\\n    var server = this._servers[i];\\r\\n    if (this._server_is_available(server)) {\\r\\n      result = server;\\r\\n      break;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return result;\\r\\n};\\r\\n\\r\\nRemote.prototype._get_server = function () {\\r\\n  var server;\\r\\n\\r\\n  if (this._server_is_available(this._primary_server)) {\\r\\n    server = this._primary_server;\\r\\n  } else {\\r\\n    server = this._next_server();\\r\\n    if (server) {\\r\\n      this._set_primary_server(server);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return server;\\r\\n};\\r\\n\\r\\n// Send a request.\\r\\n// <-> request: what to send, consumed.\\r\\nRemote.prototype.request = function (request) {\\r\\n  if (!this._servers.length) {\\r\\n    request.emit('error', new Error('No servers available'));\\r\\n  } else if (!this._connected) {\\r\\n    this.once('connect', this.request.bind(this, request));\\r\\n  } else if (request.server === null) {\\r\\n    this.emit('error', new Error('Server does not exist'));\\r\\n  } else {\\r\\n    var server = request.server || this._get_server();\\r\\n    if (server) {\\r\\n      server.request(request);\\r\\n    } else {\\r\\n      request.emit('error', new Error('No servers available'));\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nRemote.prototype.request_server_info = function(callback) {\\r\\n  return new Request(this, 'server_info').callback(callback);\\r\\n};\\r\\n\\r\\n// XXX This is a bad command. Some varients don't scale.\\r\\n// XXX Require the server to be trusted.\\r\\nRemote.prototype.request_ledger = function (ledger, opts, callback) {\\r\\n  //utils.assert(this.trusted);\\r\\n\\r\\n  var request = new Request(this, 'ledger');\\r\\n\\r\\n  if (ledger) {\\r\\n    // DEPRECATED: use .ledger_hash() or .ledger_index()\\r\\n    //console.log('request_ledger: ledger parameter is deprecated');\\r\\n    request.message.ledger  = ledger;\\r\\n  }\\r\\n\\r\\n  var props = [\\r\\n      'full'\\r\\n    , 'expand'\\r\\n    , 'transactions'\\r\\n    , 'accounts'\\r\\n  ];\\r\\n\\r\\n  switch (typeof opts) {\\r\\n    case 'object':\\r\\n      for (var key in opts) {\\r\\n        if (~props.indexOf(key)) {\\r\\n          request.message[key] = true;\\r\\n        }\\r\\n      }\\r\\n      break;\\r\\n\\r\\n    case 'function':\\r\\n      callback = opts;\\r\\n      opts = void(0);\\r\\n      break;\\r\\n\\r\\n    default:\\r\\n      //DEPRECATED\\r\\n      console.log('request_ledger: full parameter is deprecated');\\r\\n      request.message.full = true;\\r\\n      break;\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// Only for unit testing.\\r\\nRemote.prototype.request_ledger_hash = function (callback) {\\r\\n  //utils.assert(this.trusted);   // If not trusted, need to check proof.\\r\\n\\r\\n  return new Request(this, 'ledger_closed').callback(callback);\\r\\n};\\r\\n\\r\\n// .ledger()\\r\\n// .ledger_index()\\r\\nRemote.prototype.request_ledger_header = function (callback) {\\r\\n  return new Request(this, 'ledger_header').callback(callback);\\r\\n};\\r\\n\\r\\n// Get the current proposed ledger entry.  May be closed (and revised) at any time (even before returning).\\r\\n// Only for unit testing.\\r\\nRemote.prototype.request_ledger_current = function (callback) {\\r\\n  return new Request(this, 'ledger_current').callback(callback);\\r\\n};\\r\\n\\r\\n// --> type : the type of ledger entry.\\r\\n// .ledger()\\r\\n// .ledger_index()\\r\\n// .offer_id()\\r\\nRemote.prototype.request_ledger_entry = function (type, callback) {\\r\\n  //utils.assert(this.trusted);   // If not trusted, need to check proof, maybe talk packet protocol.\\r\\n\\r\\n  var self = this;\\r\\n  var request = new Request(this, 'ledger_entry');\\r\\n\\r\\n  // Transparent caching. When .request() is invoked, look in the Remote object for the result.\\r\\n  // If not found, listen, cache result, and emit it.\\r\\n  //\\r\\n  // Transparent caching:\\r\\n  if (type === 'account_root') {\\r\\n    request.request_default = request.request;\\r\\n\\r\\n    request.request = function () {                        // Intercept default request.\\r\\n      var bDefault  = true;\\r\\n      // .self = Remote\\r\\n      // this = Request\\r\\n\\r\\n      // console.log('request_ledger_entry: caught');\\r\\n\\r\\n      //if (self._ledger_hash) {\\r\\n        // A specific ledger is requested.\\r\\n        // XXX Add caching.\\r\\n        // else if (req.ledger_index)\\r\\n        // else if ('ripple_state' === request.type)         // YYY Could be cached per ledger.\\r\\n      //}\\r\\n\\r\\n      if (!self._ledger_hash && type === 'account_root') {\\r\\n        var cache = self.ledgers.current.account_root;\\r\\n\\r\\n        if (!cache) {\\r\\n          cache = self.ledgers.current.account_root = {};\\r\\n        }\\r\\n\\r\\n        var node = self.ledgers.current.account_root[request.message.account_root];\\r\\n\\r\\n        if (node) {\\r\\n          // Emulate fetch of ledger entry.\\r\\n          // console.log('request_ledger_entry: emulating');\\r\\n          // YYY Missing lots of fields.\\r\\n          request.emit('success', { node: node });\\r\\n          bDefault  = false;\\r\\n        } else { // Was not cached.\\r\\n          // XXX Only allow with trusted mode.  Must sync response with advance.\\r\\n          switch (type) {\\r\\n            case 'account_root':\\r\\n              request.once('success', function (message) {\\r\\n                // Cache node.\\r\\n                // console.log('request_ledger_entry: caching');\\r\\n                self.ledgers.current.account_root[message.node.Account] = message.node;\\r\\n              });\\r\\n              break;\\r\\n\\r\\n            default:\\r\\n              // This type not cached.\\r\\n              // console.log('request_ledger_entry: non-cached type');\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (bDefault) {\\r\\n        // console.log('request_ledger_entry: invoking');\\r\\n        request.request_default();\\r\\n      }\\r\\n    };\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// .accounts(accounts, realtime)\\r\\nRemote.prototype.request_subscribe = function (streams, callback) {\\r\\n  var request = new Request(this, 'subscribe');\\r\\n\\r\\n  if (streams) {\\r\\n    request.message.streams = Array.isArray(streams) ? streams : [ streams ];\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// .accounts(accounts, realtime)\\r\\nRemote.prototype.request_unsubscribe = function (streams, callback) {\\r\\n  var request = new Request(this, 'unsubscribe');\\r\\n\\r\\n  if (streams) {\\r\\n    request.message.streams = Array.isArray(streams) ? streams : [ streams ];\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// .ledger_choose()\\r\\n// .ledger_hash()\\r\\n// .ledger_index()\\r\\nRemote.prototype.request_transaction =\\r\\nRemote.prototype.request_transaction_entry = function (hash, ledger_hash, callback) {\\r\\n  //utils.assert(this.trusted);   // If not trusted, need to check proof, maybe talk packet protocol.\\r\\n  var request = new Request(this, 'transaction_entry');\\r\\n\\r\\n  request.tx_hash(hash);\\r\\n\\r\\n  switch (typeof ledger_hash) {\\r\\n    case 'string':\\r\\n      request.ledger_hash(ledger_hash);\\r\\n      break;\\r\\n    default:\\r\\n      request.ledger_index('validated');\\r\\n      callback = ledger_hash;\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// DEPRECATED: use request_transaction_entry\\r\\nRemote.prototype.request_tx = function (hash, callback) {\\r\\n  var request = new Request(this, 'tx');\\r\\n  request.message.transaction  = hash;\\r\\n  request.callback(callback);\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_account_info = function (accountID, callback) {\\r\\n  var request = new Request(this, 'account_info');\\r\\n  request.message.ident   = UInt160.json_rewrite(accountID);  // DEPRECATED\\r\\n  request.message.account = UInt160.json_rewrite(accountID);\\r\\n  request.callback(callback);\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.account_request = function(type, accountID, account_index, ledger, callback) {\\r\\n  if (typeof accountID === 'object') {\\r\\n    var options = accountID;\\r\\n    callback      = account_index;\\r\\n    ledger        = options.ledger;\\r\\n    account_index = options.account_index;\\r\\n    accoutID      = options.accountID;\\r\\n  }\\r\\n\\r\\n  var request = new Request(this, type);\\r\\n\\r\\n  request.message.account = UInt160.json_rewrite(accountID);\\r\\n\\r\\n  if (account_index) {\\r\\n    request.message.index = account_index;\\r\\n  }\\r\\n\\r\\n  request.ledger_choose(ledger);\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// --> account_index: sub_account index (optional)\\r\\n// --> current: true, for the current ledger.\\r\\nRemote.prototype.request_account_lines = function (accountID, account_index, ledger, callback) {\\r\\n  // XXX Does this require the server to be trusted?\\r\\n  //utils.assert(this.trusted);\\r\\n  var args = Array.prototype.slice.call(arguments);\\r\\n  args.unshift('account_lines');\\r\\n  return Remote.account_request.apply(this, args);\\r\\n};\\r\\n\\r\\n// --> account_index: sub_account index (optional)\\r\\n// --> current: true, for the current ledger.\\r\\nRemote.prototype.request_account_offers = function (accountID, account_index, ledger, callback) {\\r\\n  var args = Array.prototype.arguments.slice(arguments);\\r\\n  args.unshift('account_offers');\\r\\n  return Remote.account_request.apply(this, args);\\r\\n};\\r\\n\\r\\n/*\\r\\n  account: account,\\r\\n  ledger_index_min: ledger_index, // optional, defaults to -1 if ledger_index_max is specified.\\r\\n  ledger_index_max: ledger_index, // optional, defaults to -1 if ledger_index_min is specified.\\r\\n  binary: boolean,                // optional, defaults to false\\r\\n  count: boolean,                 // optional, defaults to false\\r\\n  descending: boolean,            // optional, defaults to false\\r\\n  offset: integer,                // optional, defaults to 0\\r\\n  limit: integer                  // optional\\r\\n*/\\r\\n\\r\\nRemote.prototype.request_account_tx = function (options, callback) {\\r\\n  // XXX Does this require the server to be trusted?\\r\\n  //utils.assert(this.trusted);\\r\\n\\r\\n  var request = new Request(this, 'account_tx');\\r\\n\\r\\n  var request_fields = [\\r\\n      'account'\\r\\n    , 'ledger_index_min'  //earliest\\r\\n    , 'ledger_index_max'  //latest\\r\\n    , 'binary'            //false\\r\\n    , 'count'             //false\\r\\n    , 'descending'        //false\\r\\n    , 'offset'            //0\\r\\n    , 'limit'\\r\\n\\r\\n    //extended account_tx\\r\\n    , 'forward'           //false\\r\\n    , 'marker'\\r\\n  ];\\r\\n\\r\\n  for (var key in options) {\\r\\n    if (~request_fields.indexOf(key)) {\\r\\n      request.message[key] = options[key];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Request the overall transaction history.\\r\\n *\\r\\n * Returns a list of transactions that happened recently on the network. The\\r\\n * default number of transactions to be returned is 20.\\r\\n */\\r\\nRemote.prototype.request_tx_history = function (start, callback) {\\r\\n  // XXX Does this require the server to be trusted?\\r\\n  //utils.assert(this.trusted);\\r\\n\\r\\n  var request = new Request(this, 'tx_history');\\r\\n\\r\\n  request.message.start = start;\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_book_offers = function (gets, pays, taker, callback) {\\r\\n  if (typeof gets === 'object') {\\r\\n    var options = gets;\\r\\n    taker = options.taker;\\r\\n    pays  = options.pays;\\r\\n    gets  = options.gets;\\r\\n  }\\r\\n\\r\\n  var request = new Request(this, 'book_offers');\\r\\n\\r\\n  request.message.taker_gets = {\\r\\n    currency: Currency.json_rewrite(gets.currency)\\r\\n  };\\r\\n\\r\\n  if (request.message.taker_gets.currency !== 'XRP') {\\r\\n    request.message.taker_gets.issuer = UInt160.json_rewrite(gets.issuer);\\r\\n  }\\r\\n\\r\\n  request.message.taker_pays = {\\r\\n    currency: Currency.json_rewrite(pays.currency)\\r\\n  };\\r\\n\\r\\n  if (request.message.taker_pays.currency !== 'XRP') {\\r\\n    request.message.taker_pays.issuer = UInt160.json_rewrite(pays.issuer);\\r\\n  }\\r\\n\\r\\n  request.message.taker = taker ? taker : UInt160.ACCOUNT_ONE;\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_wallet_accounts = function (seed, callback) {\\r\\n  utils.assert(this.trusted); // Don't send secrets.\\r\\n  var request = new Request(this, 'wallet_accounts');\\r\\n  request.message.seed = seed;\\r\\n  return request.callback(callback);\\r\\n};\\r\\n\\r\\nRemote.prototype.request_sign = function (secret, tx_json, callback) {\\r\\n  utils.assert(this.trusted); // Don't send secrets.\\r\\n  var request = new Request(this, 'sign');\\r\\n  request.message.secret  = secret;\\r\\n  request.message.tx_json = tx_json;\\r\\n  request.callback(callback);\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// Submit a transaction.\\r\\nRemote.prototype.request_submit = function (callback) {\\r\\n  return new Request(this, 'submit').callback(callback);\\r\\n};\\r\\n\\r\\n//\\r\\n// Higher level functions.\\r\\n//\\r\\n\\r\\n/**\\r\\n * Create a subscribe request with current subscriptions.\\r\\n *\\r\\n * Other classes can add their own subscriptions to this request by listening to\\r\\n * the server_subscribe event.\\r\\n *\\r\\n * This function will create and return the request, but not submit it.\\r\\n */\\r\\nRemote.prototype._server_prepare_subscribe = function (callback) {\\r\\n  var self  = this;\\r\\n\\r\\n  var feeds = [ 'ledger', 'server' ];\\r\\n\\r\\n  if (this._transaction_subs) {\\r\\n    feeds.push('transactions');\\r\\n  }\\r\\n\\r\\n  var request = this.request_subscribe(feeds);\\r\\n\\r\\n  request.once('success', function (message) {\\r\\n    self._stand_alone = !!message.stand_alone;\\r\\n    self._testnet     = !!message.testnet;\\r\\n\\r\\n    if (typeof message.random === 'string') {\\r\\n      var rand = message.random.match(/[0-9A-F]{8}/ig);\\r\\n      while (rand && rand.length) {\\r\\n        sjcl.random.addEntropy(parseInt(rand.pop(), 16));\\r\\n      }\\r\\n      self.emit('random', utils.hexToArray(message.random));\\r\\n    }\\r\\n\\r\\n    if (message.ledger_hash && message.ledger_index) {\\r\\n      self._ledger_time           = message.ledger_time;\\r\\n      self._ledger_hash           = message.ledger_hash;\\r\\n      self._ledger_current_index  = message.ledger_index+1;\\r\\n      self.emit('ledger_closed', message);\\r\\n    }\\r\\n\\r\\n    // FIXME Use this to estimate fee.\\r\\n    // XXX When we have multiple server support, most of this should be tracked\\r\\n    //     by the Server objects and then aggregated/interpreted by Remote.\\r\\n    self._load_base     = message.load_base || 256;\\r\\n    self._load_factor   = message.load_factor || 256;\\r\\n    self._fee_ref       = message.fee_ref;\\r\\n    self._fee_base      = message.fee_base;\\r\\n    self._reserve_base  = message.reserve_base;\\r\\n    self._reserve_inc   = message.reserve_inc;\\r\\n\\r\\n    self.emit('subscribed');\\r\\n  });\\r\\n\\r\\n  request.on('error', function (err) {\\r\\n    // XXX We need a better global error handling\\r\\n    //console.log(err);\\r\\n  });\\r\\n\\r\\n  self.emit('prepare_subscribe', request);\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  // XXX Could give error events, maybe even time out.\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// For unit testing: ask the remote to accept the current ledger.\\r\\n// - To be notified when the ledger is accepted, server_subscribe() then listen to 'ledger_hash' events.\\r\\n// A good way to be notified of the result of this is:\\r\\n//    remote.once('ledger_closed', function (ledger_closed, ledger_index) { ... } );\\r\\nRemote.prototype.ledger_accept = function (callback) {\\r\\n  if (this._stand_alone) {\\r\\n    var request = new Request(this, 'ledger_accept');\\r\\n    request.request();\\r\\n    request.callback(callback);\\r\\n  } else {\\r\\n    this.emit('error', new RippleError('notStandAlone'));\\r\\n  }\\r\\n  return this;\\r\\n};\\r\\n\\r\\n// Return a request to refresh the account balance.\\r\\nRemote.prototype.request_account_balance = function (account, ledger, callback) {\\r\\n  if (typeof account === 'object') {\\r\\n    callback = ledger;\\r\\n    ledger   = account.ledger;\\r\\n    account  = account.account;\\r\\n  }\\r\\n\\r\\n  var request = this.request_ledger_entry('account_root');\\r\\n  request.account_root(account);\\r\\n  request.ledger_choose(ledger);\\r\\n  request.once('success', function (message) {\\r\\n    request.emit('account_balance', Amount.from_json(message.node.Balance));\\r\\n  });\\r\\n  request.callback(callback, 'account_balance');\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// Return a request to return the account flags.\\r\\nRemote.prototype.request_account_flags = function (account, ledger, callback) {\\r\\n  if (typeof account === 'object') {\\r\\n    callback = ledger;\\r\\n    ledger   = account.ledger;\\r\\n    account  = account.account;\\r\\n  }\\r\\n\\r\\n  var request = this.request_ledger_entry('account_root');\\r\\n  request.account_root(account);\\r\\n  request.ledger_choose(ledger);\\r\\n  request.once('success', function (message) {\\r\\n    request.emit('account_flags', message.node.Flags);\\r\\n  });\\r\\n  request.callback(callback, 'account_flags');\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// Return a request to emit the owner count.\\r\\nRemote.prototype.request_owner_count = function (account, ledger, callback) {\\r\\n  if (typeof account === 'object') {\\r\\n    callback = ledger;\\r\\n    ledger   = account.ledger;\\r\\n    account  = account.account;\\r\\n  }\\r\\n\\r\\n  var request = this.request_ledger_entry('account_root');\\r\\n  request.account_root(account);\\r\\n  request.ledger_choose(ledger);\\r\\n  request.once('success', function (message) {\\r\\n    request.emit('owner_count', message.node.OwnerCount);\\r\\n  });\\r\\n  request.callback(callback, 'owner_count');\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.get_account = function(accountID) {\\r\\n  return this._accounts[UInt160.json_rewrite(accountID)];\\r\\n};\\r\\n\\r\\nRemote.prototype.add_account = function(accountID) {\\r\\n  var account = new Account(this, accountID);\\r\\n  if (account.is_valid()) {\\r\\n    this._accounts[accountID] = account;\\r\\n  }\\r\\n  return account;\\r\\n};\\r\\n\\r\\nRemote.prototype.account = function (accountID) {\\r\\n  var account = this.get_account(accountID);\\r\\n  return account ? account : this.add_account(accountID);\\r\\n};\\r\\n\\r\\nRemote.prototype.path_find = function (src_account, dst_account, dst_amount, src_currencies) {\\r\\n  if (typeof src_account === 'object') {\\r\\n    var options = src_account;\\r\\n    src_currencies = options.src_currencies;\\r\\n    dst_amount     = options.dst_amount;\\r\\n    dst_account    = options.dst_account;\\r\\n    src_account    = options.src_account;\\r\\n  }\\r\\n\\r\\n  var path_find = new PathFind(this, src_account, dst_account, dst_amount, src_currencies);\\r\\n\\r\\n  if (this._cur_path_find) {\\r\\n    this._cur_path_find.notify_superceded();\\r\\n  }\\r\\n\\r\\n  path_find.create();\\r\\n\\r\\n  this._cur_path_find = path_find;\\r\\n\\r\\n  return path_find;\\r\\n};\\r\\n\\r\\nRemote.prepare_trade = function(currency, issuer) {\\r\\n  return currency + (currency === 'XRP' ? '' : ('/' + issuer));\\r\\n};\\r\\n\\r\\nRemote.prototype.book = function (currency_gets, issuer_gets, currency_pays, issuer_pays) {\\r\\n  if (typeof currency_gets === 'object') {\\r\\n    var options = currency_gets;\\r\\n    issuer_pays   = options.issuer_pays;\\r\\n    currency_pays = options.currency_pays;\\r\\n    issuer_gets   = options.issuer_gets;\\r\\n    currency_gets = options.currency_gets;\\r\\n  }\\r\\n\\r\\n  var gets = Remote.prepare_trade(currency_gets, issuer_gets);\\r\\n  var pays = Remote.prepare_trade(currency_pays, issuer_pays);\\r\\n  var key = gets + ':' + pays;\\r\\n  var book;\\r\\n\\r\\n  if (!this._books.hasOwnProperty(key)) {\\r\\n    book = new OrderBook(this, currency_gets, issuer_gets, currency_pays, issuer_pays);\\r\\n    if (book.is_valid()) {\\r\\n      this._books[key] = book;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return this._books[key];\\r\\n};\\r\\n\\r\\n// Return the next account sequence if possible.\\r\\n// <-- undefined or Sequence\\r\\nRemote.prototype.account_seq = function (account, advance) {\\r\\n  var account      = UInt160.json_rewrite(account);\\r\\n  var account_info = this.accounts[account];\\r\\n  var seq;\\r\\n\\r\\n  if (account_info && account_info.seq) {\\r\\n    seq = account_info.seq;\\r\\n    var change = { ADVANCE: 1, REWIND: -1 }[advance.toUpperCase()] || 0;\\r\\n    account_info.seq += change;\\r\\n  }\\r\\n\\r\\n  return seq;\\r\\n};\\r\\n\\r\\nRemote.prototype.set_account_seq = function (account, seq) {\\r\\n  var account = UInt160.json_rewrite(account);\\r\\n\\r\\n  if (!this.accounts.hasOwnProperty(account)) {\\r\\n    this.accounts[account] = { };\\r\\n  }\\r\\n\\r\\n  this.accounts[account].seq = seq;\\r\\n}\\r\\n\\r\\n// Return a request to refresh accounts[account].seq.\\r\\nRemote.prototype.account_seq_cache = function (account, ledger, callback) {\\r\\n  if (typeof account === 'object') {\\r\\n    var options = account;\\r\\n    callback = ledger;\\r\\n    ledger   = options.ledger;\\r\\n    account  = options.account;\\r\\n  }\\r\\n\\r\\n  var self = this;\\r\\n\\r\\n  if (!this.accounts.hasOwnProperty(account)) {\\r\\n    this.accounts[account] = { };\\r\\n  }\\r\\n\\r\\n  var account_info = this.accounts[account];\\r\\n  var request      = account_info.caching_seq_request;\\r\\n\\r\\n  if (!request) {\\r\\n    // console.log('starting: %s', account);\\r\\n    request = this.request_ledger_entry('account_root');\\r\\n    request.account_root(account);\\r\\n    request.ledger_choose(ledger);\\r\\n\\r\\n    function account_root_success(message) {\\r\\n      delete account_info.caching_seq_request;\\r\\n\\r\\n      var seq = message.node.Sequence;\\r\\n      account_info.seq  = seq;\\r\\n\\r\\n      // console.log('caching: %s %d', account, seq);\\r\\n      // If the caller also waits for 'success', they might run before this.\\r\\n      request.emit('success_account_seq_cache', message);\\r\\n    }\\r\\n\\r\\n    function account_root_error(message) {\\r\\n      // console.log('error: %s', account);\\r\\n      delete account_info.caching_seq_request;\\r\\n\\r\\n      request.emit('error_account_seq_cache', message);\\r\\n    }\\r\\n\\r\\n    request.once('success', account_root_success);\\r\\n    request.once('error', account_root_error);\\r\\n\\r\\n    account_info.caching_seq_request = request;\\r\\n  }\\r\\n\\r\\n  request.callback(callback, 'success_account_seq_cache', 'error_account_seq_cache');\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// Mark an account's root node as dirty.\\r\\nRemote.prototype.dirty_account_root = function (account) {\\r\\n  var account = UInt160.json_rewrite(account);\\r\\n  delete this.ledgers.current.account_root[account];\\r\\n};\\r\\n\\r\\n// Store a secret - allows the Remote to automatically fill out auth information.\\r\\nRemote.prototype.set_secret = function (account, secret) {\\r\\n  this.secrets[account] = secret;\\r\\n};\\r\\n\\r\\n\\r\\n// Return a request to get a ripple balance.\\r\\n//\\r\\n// --> account: String\\r\\n// --> issuer: String\\r\\n// --> currency: String\\r\\n// --> current: bool : true = current ledger\\r\\n//\\r\\n// If does not exist: emit('error', 'error' : 'remoteError', 'remote' : { 'error' : 'entryNotFound' })\\r\\nRemote.prototype.request_ripple_balance = function (account, issuer, currency, ledger, callback) {\\r\\n  if (typeof account === 'object') {\\r\\n    var options = account;\\r\\n    callback = issuer;\\r\\n    ledger   = options.ledger;\\r\\n    currency = options.currency;\\r\\n    issuer   = options.issuer;\\r\\n    account  = options.account;\\r\\n  }\\r\\n\\r\\n  var request = this.request_ledger_entry('ripple_state'); // YYY Could be cached per ledger.\\r\\n\\r\\n  request.ripple_state(account, issuer, currency);\\r\\n  request.ledger_choose(ledger);\\r\\n  request.once('success', function(message) {\\r\\n    var node            = message.node;\\r\\n    var lowLimit        = Amount.from_json(node.LowLimit);\\r\\n    var highLimit       = Amount.from_json(node.HighLimit);\\r\\n    // The amount the low account holds of issuer.\\r\\n    var balance         = Amount.from_json(node.Balance);\\r\\n    // accountHigh implies: for account: balance is negated, highLimit is the limit set by account.\\r\\n    var accountHigh     = UInt160.from_json(account).equals(highLimit.issuer());\\r\\n\\r\\n    request.emit('ripple_state', {\\r\\n      account_balance     : ( accountHigh ? balance.negate() : balance.clone()).parse_issuer(account),\\r\\n      peer_balance        : (!accountHigh ? balance.negate() : balance.clone()).parse_issuer(issuer),\\r\\n\\r\\n      account_limit       : ( accountHigh ? highLimit : lowLimit).clone().parse_issuer(issuer),\\r\\n      peer_limit          : (!accountHigh ? highLimit : lowLimit).clone().parse_issuer(account),\\r\\n\\r\\n      account_quality_in  : ( accountHigh ? node.HighQualityIn : node.LowQualityIn),\\r\\n      peer_quality_in     : (!accountHigh ? node.HighQualityIn : node.LowQualityIn),\\r\\n\\r\\n      account_quality_out : ( accountHigh ? node.HighQualityOut : node.LowQualityOut),\\r\\n      peer_quality_out    : (!accountHigh ? node.HighQualityOut : node.LowQualityOut),\\r\\n    });\\r\\n  });\\r\\n\\r\\n  request.callback(callback, 'ripple_state');\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prepare_currencies = function(ci) {\\r\\n  var ci_new  = { };\\r\\n\\r\\n  if (ci.hasOwnProperty('issuer')) {\\r\\n    ci_new.issuer = UInt160.json_rewrite(ci.issuer);\\r\\n  }\\r\\n\\r\\n  if (ci.hasOwnProperty('currency')) {\\r\\n    ci_new.currency = Currency.json_rewrite(ci.currency);\\r\\n  }\\r\\n\\r\\n  return ci_new;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_ripple_path_find = function (src_account, dst_account, dst_amount, src_currencies, callback) {\\r\\n  if (typeof src_account === 'object') {\\r\\n    var options = src_account;\\r\\n    callback       = dst_account;\\r\\n    src_currencies = options.src_currencies;\\r\\n    dst_amount     = options.dst_amount;\\r\\n    dst_account    = options.dst_account;\\r\\n    src_account    = options.src_account;\\r\\n  }\\r\\n\\r\\n  var request = new Request(this, 'ripple_path_find');\\r\\n\\r\\n  request.message.source_account      = UInt160.json_rewrite(src_account);\\r\\n  request.message.destination_account = UInt160.json_rewrite(dst_account);\\r\\n  request.message.destination_amount  = Amount.json_rewrite(dst_amount);\\r\\n\\r\\n  if (src_currencies) {\\r\\n    request.message.source_currencies = src_currencies.map(Remote.prepare_currencies);\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_path_find_create = function (src_account, dst_account, dst_amount, src_currencies, callback) {\\r\\n  if (typeof src_account === 'object') {\\r\\n    var options = src_account;\\r\\n    callback       = dst_account;\\r\\n    src_currencies = options.src_currencies;\\r\\n    dst_amount     = options.dst_amount;\\r\\n    dst_account    = options.dst_account;\\r\\n    src_account    = options.src_account;\\r\\n  }\\r\\n\\r\\n  var request = new Request(this, 'path_find');\\r\\n\\r\\n  request.message.subcommand          = 'create';\\r\\n  request.message.source_account      = UInt160.json_rewrite(src_account);\\r\\n  request.message.destination_account = UInt160.json_rewrite(dst_account);\\r\\n  request.message.destination_amount  = Amount.json_rewrite(dst_amount);\\r\\n\\r\\n  if (src_currencies) {\\r\\n    request.message.source_currencies = src_currencies.map(Remote.prepare_currencies);\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_path_find_close = function () {\\r\\n  var request = new Request(this, 'path_find');\\r\\n  request.message.subcommand = 'close';\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_unl_list = function (callback) {\\r\\n  return new Request(this, 'unl_list').callback(callback);\\r\\n};\\r\\n\\r\\nRemote.prototype.request_unl_add = function (addr, comment, callback) {\\r\\n  var request = new Request(this, 'unl_add');\\r\\n\\r\\n  request.message.node = addr;\\r\\n\\r\\n  if (comment) {\\r\\n    request.message.comment = note;\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\n// --> node: <domain> | <public_key>\\r\\nRemote.prototype.request_unl_delete = function (node, callback) {\\r\\n  var request = new Request(this, 'unl_delete');\\r\\n  request.message.node = node;\\r\\n  request.callback(callback);\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.request_peers = function (callback) {\\r\\n  return new Request(this, 'peers').callback(callback);\\r\\n};\\r\\n\\r\\nRemote.prototype.request_connect = function (ip, port, callback) {\\r\\n  var request = new Request(this, 'connect');\\r\\n\\r\\n  request.message.ip = ip;\\r\\n\\r\\n  if (port) {\\r\\n    request.message.port = port;\\r\\n  }\\r\\n\\r\\n  request.callback(callback);\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nRemote.prototype.transaction = function (source, destination, amount, callback) {\\r\\n  var tx = new Transaction(this);\\r\\n\\r\\n  if (arguments.length >= 3) {\\r\\n    tx = tx.payment(source, destination, amount);\\r\\n    if (typeof callback === 'function') {\\r\\n      tx.submit(callback);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return tx;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Calculate a transaction fee for a number of tx fee units.\\r\\n *\\r\\n * This takes into account the last known network and local load fees.\\r\\n *\\r\\n * @return {Amount} Final fee in XRP for specified number of fee units.\\r\\n */\\r\\nRemote.prototype.fee_tx = function (units) {\\r\\n  var fee_unit = this.fee_tx_unit();\\r\\n  return Amount.from_json(String(Math.ceil(units * fee_unit)));\\r\\n};\\r\\n\\r\\n/**\\r\\n * Get the current recommended transaction fee unit.\\r\\n *\\r\\n * Multiply this value with the number of fee units in order to calculate the\\r\\n * recommended fee for the transaction you are trying to submit.\\r\\n *\\r\\n * @return {Number} Recommended amount for one fee unit as float.\\r\\n */\\r\\nRemote.prototype.fee_tx_unit = function () {\\r\\n  var fee_unit = this._fee_base / this._fee_ref;\\r\\n\\r\\n  // Apply load fees\\r\\n  fee_unit *= this._load_factor / this._load_base;\\r\\n\\r\\n  // Apply fee cushion (a safety margin in case fees rise since we were last updated\\r\\n  fee_unit *= this.fee_cushion;\\r\\n\\r\\n  return fee_unit;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Get the current recommended reserve base.\\r\\n *\\r\\n * Returns the base reserve with load fees and safety margin applied.\\r\\n */\\r\\nRemote.prototype.reserve = function (owner_count) {\\r\\n  var reserve_base = Amount.from_json(String(this._reserve_base));\\r\\n  var reserve_inc  = Amount.from_json(String(this._reserve_inc));\\r\\n  var owner_count  = owner_count || 0;\\r\\n\\r\\n  if (owner_count < 0) {\\r\\n    throw new Error('Owner count must not be negative.');\\r\\n  }\\r\\n\\r\\n  return reserve_base.add(reserve_inc.product_human(owner_count));\\r\\n};\\r\\n\\r\\nRemote.prototype.ping = function(host, callback) {\\r\\n  var request = new Request(this, 'ping');\\r\\n\\r\\n  switch (typeof host) {\\r\\n    case 'function':\\r\\n      callback = host;\\r\\n      break;\\r\\n    case 'string':\\r\\n      request.set_server(host);\\r\\n      break;\\r\\n  }\\r\\n\\r\\n  var then = Date.now();\\r\\n\\r\\n  request.once('success', function() {\\r\\n    request.emit('pong', Date.now() - then);\\r\\n  });\\r\\n\\r\\n  request.callback(callback, 'pong');\\r\\n\\r\\n  return request;\\r\\n};\\r\\n\\r\\nexports.Remote = Remote;\\r\\n\\r\\n// vim:sw=2:sts=2:ts=8:et\\r\\n\\n\\n// WEBPACK FOOTER\\n// module.id = 1\\n// module.readableIdentifier = ./src/js/ripple/remote.js\\n//@ sourceURL=webpack-module:///./src/js/ripple/remote.js\");","\t129: \teval(\"var EventEmitter = require(27).EventEmitter;\\r\\nvar util         = require(28);\\r\\nvar utils        = require(9);\\r\\n\\r\\n/**\\r\\n *  @constructor Server\\r\\n *  @param  remote    The Remote object\\r\\n *  @param  opts       Configuration parameters.\\r\\n *\\r\\n *  Keys for cfg:\\r\\n *  url\\r\\n */ \\r\\n\\r\\nfunction Server(remote, opts) {\\r\\n  EventEmitter.call(this);\\r\\n\\r\\n  if (typeof opts !== 'object') {\\r\\n    throw new Error('Invalid server configuration.');\\r\\n  }\\r\\n\\r\\n  var self = this;\\r\\n\\r\\n  this._remote         = remote;\\r\\n  this._opts           = opts;\\r\\n  this._host           = opts.host;\\r\\n  this._port           = opts.port;\\r\\n  this._secure         = typeof opts.secure === 'boolean' ? opts.secure : true;\\r\\n  this._ws             = void(0);\\r\\n  this._connected      = false;\\r\\n  this._should_connect = false;\\r\\n  this._state          = void(0);\\r\\n  this._id             = 0;\\r\\n  this._retry          = 0;\\r\\n  this._requests       = { };\\r\\n\\r\\n  this._opts.url = (opts.secure ? 'wss://' : 'ws://') + opts.host + ':' + opts.port;\\r\\n\\r\\n  this.on('message', function(message) {\\r\\n    self._handle_message(message);\\r\\n  });\\r\\n\\r\\n  this.on('response_subscribe', function(message) {\\r\\n    self._handle_response_subscribe(message);\\r\\n  });\\r\\n}\\r\\n\\r\\nutil.inherits(Server, EventEmitter);\\r\\n\\r\\n/**\\r\\n * Server states that we will treat as the server being online.\\r\\n *\\r\\n * Our requirements are that the server can process transactions and notify\\r\\n * us of changes.\\r\\n */\\r\\nServer.online_states = [\\r\\n    'syncing'\\r\\n  , 'tracking'\\r\\n  , 'proposing'\\r\\n  , 'validating'\\r\\n  , 'full'\\r\\n];\\r\\n\\r\\nServer.prototype._is_online = function (status) {\\r\\n  return Server.online_states.indexOf(status) !== -1;\\r\\n};\\r\\n\\r\\nServer.prototype._set_state = function (state) {\\r\\n  if (state !== this._state) {\\r\\n    this._state = state;\\r\\n\\r\\n    this.emit('state', state);\\r\\n\\r\\n    switch (state) {\\r\\n      case 'online':\\r\\n        this._connected = true;\\r\\n        this.emit('connect');\\r\\n        break;\\r\\n      case 'offline':\\r\\n        this._connected = false;\\r\\n        this.emit('disconnect');\\r\\n        break;\\r\\n    }\\r\\n  }\\r\\n};\\r\\n\\r\\nServer.prototype._trace = function() {\\r\\n  if (this._remote.trace) {\\r\\n    utils.logObject.apply(utils, arguments);\\r\\n  }\\r\\n};\\r\\n\\r\\nServer.prototype._remote_address = function() {\\r\\n  try { var address = this._ws._socket.remoteAddress; } catch (e) { }\\r\\n  return address;\\r\\n};\\r\\n\\r\\n// This is the final interface between client code and a socket connection to a\\r\\n// `rippled` server. As such, this is a decent hook point to allow a WebSocket\\r\\n// interface conforming object to be used as a basis to mock rippled. This\\r\\n// avoids the need to bind a websocket server to a port and allows a more\\r\\n// synchronous style of code to represent a client <-> server message sequence.\\r\\n// We can also use this to log a message sequence to a buffer.\\r\\nServer.prototype.websocket_constructor = function () {\\r\\n  return require(26);\\r\\n};\\r\\n\\r\\nServer.prototype.connect = function () {\\r\\n  var self = this;\\r\\n\\r\\n  // We don't connect if we believe we're already connected. This means we have\\r\\n  // recently received a message from the server and the WebSocket has not\\r\\n  // reported any issues either. If we do fail to ping or the connection drops,\\r\\n  // we will automatically reconnect.\\r\\n  if (this._connected) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  this._trace('server: connect: %s', this._opts.url);\\r\\n\\r\\n  // Ensure any existing socket is given the command to close first.\\r\\n  if (this._ws) {\\r\\n    this._ws.close();\\r\\n  }\\r\\n\\r\\n  // We require this late, because websocket shims may be loaded after\\r\\n  // ripple-lib.\\r\\n  var WebSocket = this.websocket_constructor();\\r\\n  var ws = this._ws = new WebSocket(this._opts.url);\\r\\n\\r\\n  this._should_connect = true;\\r\\n\\r\\n  self.emit('connecting');\\r\\n\\r\\n  ws.onopen = function () {\\r\\n    // If we are no longer the active socket, simply ignore any event\\r\\n    if (ws === self._ws) {\\r\\n      self.emit('socket_open');\\r\\n      // Subscribe to events\\r\\n      var request = self._remote._server_prepare_subscribe();\\r\\n      self.request(request);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  ws.onerror = function (e) {\\r\\n    // If we are no longer the active socket, simply ignore any event\\r\\n    if (ws === self._ws) {\\r\\n      self._trace('server: onerror: %s', e.data || e);\\r\\n\\r\\n      // Most connection errors for WebSockets are conveyed as 'close' events with\\r\\n      // code 1006. This is done for security purposes and therefore unlikely to\\r\\n      // ever change.\\r\\n\\r\\n      // This means that this handler is hardly ever called in practice. If it is,\\r\\n      // it probably means the server's WebSocket implementation is corrupt, or\\r\\n      // the connection is somehow producing corrupt data.\\r\\n\\r\\n      // Most WebSocket applications simply log and ignore this error. Once we\\r\\n      // support for multiple servers, we may consider doing something like\\r\\n      // lowering this server's quality score.\\r\\n\\r\\n      // However, in Node.js this event may be triggered instead of the close\\r\\n      // event, so we need to handle it.\\r\\n      handleConnectionClose();\\r\\n    }\\r\\n  };\\r\\n\\r\\n  // Failure to open.\\r\\n  ws.onclose = function () {\\r\\n    // If we are no longer the active socket, simply ignore any event\\r\\n    if (ws === self._ws) {\\r\\n      self._trace('server: onclose: %s', ws.readyState);\\r\\n      handleConnectionClose();\\r\\n    }\\r\\n  };\\r\\n\\r\\n  function handleConnectionClose() {\\r\\n    self.emit('socket_close');\\r\\n    self._set_state('offline');\\r\\n\\r\\n    // Prevent additional events from this socket\\r\\n    ws.onopen = ws.onerror = ws.onclose = ws.onmessage = function () {};\\r\\n\\r\\n    // Should we be connected?\\r\\n    if (!self._should_connect) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Delay and retry.\\r\\n    self._retry      += 1;\\r\\n    self._retry_timer = setTimeout(function () {\\r\\n      self._trace('server: retry');\\r\\n      if (!self._should_connect) {\\r\\n        return;\\r\\n      }\\r\\n      self.connect();\\r\\n    }, self._retry < 40\\r\\n        ? 1000/20           // First, for 2 seconds: 20 times per second\\r\\n        : self._retry < 40+60\\r\\n          ? 1000            // Then, for 1 minute: once per second\\r\\n          : self._retry < 40+60+60\\r\\n            ? 10*1000       // Then, for 10 minutes: once every 10 seconds\\r\\n            : 30*1000);     // Then: once every 30 seconds\\r\\n  }\\r\\n\\r\\n  ws.onmessage = function (msg) {\\r\\n    self.emit('message', msg.data);\\r\\n  };\\r\\n};\\r\\n\\r\\nServer.prototype.disconnect = function () {\\r\\n  this._should_connect = false;\\r\\n  this._set_state('offline');\\r\\n  if (this._ws) {\\r\\n    this._ws.close();\\r\\n  }\\r\\n};\\r\\n\\r\\nServer.prototype.send_message = function (message) {\\r\\n  if (this._ws) {\\r\\n    this._ws.send(JSON.stringify(message));\\r\\n  }\\r\\n};\\r\\n\\r\\n/**\\r\\n * Submit a Request object to this server.\\r\\n */\\r\\nServer.prototype.request = function (request) {\\r\\n  var self  = this;\\r\\n\\r\\n  // Only bother if we are still connected.\\r\\n  if (this._ws) {\\r\\n    request.server     = this;\\r\\n    request.message.id = this._id;\\r\\n\\r\\n    this._requests[request.message.id] = request;\\r\\n\\r\\n    // Advance message ID\\r\\n    this._id++;\\r\\n\\r\\n    var is_connected = this._connected || (request.message.command === 'subscribe' && this._ws.readyState === 1);\\r\\n    \\r\\n    if (is_connected) {\\r\\n      this._trace('server: request: %s', request.message);\\r\\n      this.send_message(request.message);\\r\\n    } else {\\r\\n      // XXX There are many ways to make this smarter.\\r\\n      function server_reconnected() {\\r\\n        self._trace('server: request: %s', request.message);\\r\\n        self.send_message(request.message);\\r\\n      }\\r\\n      this.once('connect', server_reconnected);\\r\\n    }\\r\\n  } else {\\r\\n    this._trace('server: request: DROPPING: %s', request.message);\\r\\n  }\\r\\n};\\r\\n\\r\\nServer.prototype._handle_message = function (message) {\\r\\n  var self = this;\\r\\n\\r\\n  try { message = JSON.parse(message); } catch(e) { }\\r\\n\\r\\n  var unexpected = typeof message !== 'object' || typeof message.type !== 'string';\\r\\n\\r\\n  if (unexpected) {\\r\\n    return; \\r\\n  }\\r\\n\\r\\n  switch (message.type) {\\r\\n    case 'response':\\r\\n      // A response to a request.\\r\\n      var request = self._requests[message.id];\\r\\n      delete self._requests[message.id];\\r\\n\\r\\n      if (!request) {\\r\\n        this._trace('server: UNEXPECTED: %s', message);\\r\\n      } else if ('success' === message.status) {\\r\\n        this._trace('server: response: %s', message);\\r\\n\\r\\n        request.emit('success', message.result);\\r\\n\\r\\n        [ self, self._remote ].forEach(function(emitter) {\\r\\n          emitter.emit('response_' + request.message.command, message.result, request, message);\\r\\n        });\\r\\n      } else if (message.error) {\\r\\n        this._trace('server: error: %s', message);\\r\\n\\r\\n        request.emit('error', {\\r\\n          error         : 'remoteError',\\r\\n          error_message : 'Remote reported an error.',\\r\\n          remote        : message\\r\\n        });\\r\\n      }\\r\\n      break;\\r\\n\\r\\n    case 'path_find':\\r\\n      if (self._remote.trace) utils.logObject('server: path_find: %s', message);\\r\\n      break;\\r\\n\\r\\n    case 'serverStatus':\\r\\n      // This message is only received when online. As we are connected, it is the definative final state.\\r\\n      this._set_state(this._is_online(message.server_status) ? 'online' : 'offline');\\r\\n      break;\\r\\n  }\\r\\n}\\r\\n\\r\\nServer.prototype._handle_response_subscribe = function (message) {\\r\\n  this._server_status = message.server_status;\\r\\n  if (this._is_online(message.server_status)) {\\r\\n    this._set_state('online');\\r\\n  }\\r\\n}\\r\\n\\r\\nexports.Server = Server;\\r\\n\\r\\n// vim:sw=2:sts=2:ts=8:et\\r\\n\\n\\n// WEBPACK FOOTER\\n// module.id = 11\\n// module.readableIdentifier = ./src/js/ripple/server.js\\n//@ sourceURL=webpack-module:///./src/js/ripple/server.js\");","\t234: \teval(\"// If there is no WebSocket, try MozWebSocket (support for some old browsers)\\r\\ntry {\\r\\n  module.exports = WebSocket\\r\\n} catch(err) {\\r\\n  module.exports = MozWebSocket\\r\\n}\\n\\n// WEBPACK FOOTER\\n// module.id = 26\\n// module.readableIdentifier = ./web_modules/ws.js\\n//@ sourceURL=webpack-module:///./web_modules/ws.js\");","","/basicincome_co/dependencies/ripple-0.9.2.js:","\t118: \t//   http://www.w3.org/TR/websockets/#the-websocket-interface","\t123: \t// private WebSocket interfaces. The JavaScript class for the peer protocol","\t156: \t *    This implementation uses WebSockets.","\t304: \t  if (!opts.hasOwnProperty('servers') && opts.hasOwnProperty('websocket_ip')) {","\t307: \t        host:     opts.websocket_ip,","\t308: \t        port:     opts.websocket_port,","\t309: \t        secure:   opts.websocket_ssl,","\t8804: \t * `rippled` server. As such, this is a decent hook point to allow a WebSocket","\t8806: \t * avoids the need to bind a websocket server to a port and allows a more","\t8813: \tServer.websocketConstructor = function() {","\t8814: \t  // We require this late, because websocket shims may be loaded after","\t8951: \t * Disconnect from rippled WebSocket server","\t8980: \t * Reconnect to rippled WebSocket server","\t9005: \t * Connect to rippled WebSocket server and subscribe to events that are","\t9015: \t  var WebSocket = Server.websocketConstructor();","\t9017: \t  if (!WebSocket) {","\t9018: \t    throw new Error('No websocket support detected!');","\t9022: \t  // recently received a message from the server and the WebSocket has not","\t9038: \t  var ws = this._ws = new WebSocket(this._opts.url);","\t9064: \t      // Most connection errors for WebSockets are conveyed as 'close' events with","\t9069: \t      // it probably means the server's WebSocket implementation is corrupt, or","\t9072: \t      // Most WebSocket applications simply log and ignore this error. Once we","\t9151: \t * Handle incoming messages from rippled WebSocket server","\t9335: \t * Send JSON message to rippled WebSocket server","\t9354: \t * rippled WebSocket server","\t25505: \t * WebSocket constructor.","\t25508: \tvar WebSocket = global.WebSocket || global.MozWebSocket;","\t25514: \tmodule.exports = WebSocket ? ws : null;","\t25517: \t * WebSocket constructor.","\t25532: \t    instance = new WebSocket(uri, protocols);","\t25534: \t    instance = new WebSocket(uri);","\t25539: \tif (WebSocket) ws.prototype = WebSocket.prototype;","","/fireworks/index.html:","\t69:     // WEBSOCKET OPTIONS","\t72:         \"websocket_ip\" : \"s1.ripple.com\",","\t73:         \"websocket_port\" : 443,","\t74:         \"websocket_ssl\" : true","\t80:     function startWebsocket(callback) {","\t83:       var url = (Options.server.websocket_ssl ? 'wss://' : 'ws://')","\t84:       + Options.server.websocket_ip + ':'","\t85:       + Options.server.websocket_port;","\t87:       server.socket = new WebSocket(url);","\t90:         console.log(\"opened websocket\");","\t105:         console.log(\"disconnected from websocket; connect after 5 seconds\");","\t106:         setTimeout(startWebsocket, 1000 * 5);","\t112:       startWebsocket();","\t116:       var hasWebSocket = !ONLINE || ('WebSocket' in window && window.WebSocket.CLOSING === 2);","\t118:       if (hasWebSocket && hasWebGL) {","","Found 79 matches in 3 files ","",""]},{"start":{"row":0,"column":0},"end":{"row":0,"column":1},"action":"remove","lines":[" "]},{"start":{"row":0,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["Searching for \u0001pointer-events\u0001 in\u0001/basicincome_co\u0001","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":0},"end":{"row":3,"column":0},"action":"insert","lines":["/basicincome_co/gralb.js:",""]},{"start":{"row":3,"column":0},"end":{"row":5,"column":0},"action":"insert","lines":["\t851: \t.attr(\"height\", h).attr(\"pointer-events\", \"all\")","",""]},{"start":{"row":5,"column":0},"end":{"row":8,"column":0},"action":"insert","lines":["/basicincome_co/graph_script.js:","\t849: \t.attr(\"height\", h).attr(\"pointer-events\", \"all\")","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":8,"column":0},"end":{"row":9,"column":0},"action":"insert","lines":["Found 2 matches in 2 files ",""]}]}],[{"group":"doc","deltas":[{"start":{"row":9,"column":0},"end":{"row":10,"column":0},"action":"insert","lines":["",""]},{"start":{"row":0,"column":50},"end":{"row":0,"column":79},"action":"insert","lines":[" (Found 2 matches in 2 files)"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":10,"column":0},"action":"remove","lines":["Searching for \u0001pointer-events\u0001 in\u0001/basicincome_co\u0001 (Found 2 matches in 2 files)","","/basicincome_co/gralb.js:","\t851: \t.attr(\"height\", h).attr(\"pointer-events\", \"all\")","","/basicincome_co/graph_script.js:","\t849: \t.attr(\"height\", h).attr(\"pointer-events\", \"all\")","","Found 2 matches in 2 files ","",""]},{"start":{"row":0,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["Searching for \u0001pointer-events\u0001 in\u0001the entire project\u0001","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":0},"end":{"row":3,"column":0},"action":"insert","lines":["/index.html:",""]},{"start":{"row":3,"column":0},"end":{"row":8,"column":0},"action":"insert","lines":["\t68: <div class=\"light midsize mediumgray\" style=\"position: absolute; top: -72px;\tleft:35px; pointer-events:auto\">","\t86: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" id=\"zoomInButton\" value=\"+\" onclick=\"zoomIn();\" disabled=\"disabled\"/><br/>","\t87: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" value=\"&ndash;\" onclick=\"zoomOut();\"/>","\t97: <div id=\"information\" style=\"opacity:0.8; background-color:#fff; position:absolute; top:704px; width:100%; border: 1px solid #c8c8c8; margin-left:-1px; pointer-events:auto;\">","",""]},{"start":{"row":8,"column":0},"end":{"row":11,"column":0},"action":"insert","lines":["/mainstylesheet.css:","\t76:   pointer-events:auto;","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":11,"column":0},"end":{"row":14,"column":0},"action":"insert","lines":["/basicincome_co/gralb.js:","\t851: \t.attr(\"height\", h).attr(\"pointer-events\", \"all\")","",""]},{"start":{"row":14,"column":0},"end":{"row":17,"column":0},"action":"insert","lines":["/basicincome_co/graph_script.js:","\t849: \t.attr(\"height\", h).attr(\"pointer-events\", \"all\")","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":17,"column":0},"end":{"row":18,"column":0},"action":"insert","lines":["Found 7 matches in 4 files ",""]},{"start":{"row":18,"column":0},"end":{"row":19,"column":0},"action":"insert","lines":["",""]},{"start":{"row":0,"column":53},"end":{"row":0,"column":82},"action":"insert","lines":[" (Found 7 matches in 4 files)"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":19,"column":0},"action":"remove","lines":["Searching for \u0001pointer-events\u0001 in\u0001the entire project\u0001 (Found 7 matches in 4 files)","","/index.html:","\t68: <div class=\"light midsize mediumgray\" style=\"position: absolute; top: -72px;\tleft:35px; pointer-events:auto\">","\t86: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" id=\"zoomInButton\" value=\"+\" onclick=\"zoomIn();\" disabled=\"disabled\"/><br/>","\t87: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" value=\"&ndash;\" onclick=\"zoomOut();\"/>","\t97: <div id=\"information\" style=\"opacity:0.8; background-color:#fff; position:absolute; top:704px; width:100%; border: 1px solid #c8c8c8; margin-left:-1px; pointer-events:auto;\">","","/mainstylesheet.css:","\t76:   pointer-events:auto;","","/basicincome_co/gralb.js:","\t851: \t.attr(\"height\", h).attr(\"pointer-events\", \"all\")","","/basicincome_co/graph_script.js:","\t849: \t.attr(\"height\", h).attr(\"pointer-events\", \"all\")","","Found 7 matches in 4 files ","",""]},{"start":{"row":0,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["Searching for \u0001pointer-events:auto;\u0001 in\u0001the entire project\u0001","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":0},"end":{"row":3,"column":0},"action":"insert","lines":["/index.html:",""]},{"start":{"row":3,"column":0},"end":{"row":7,"column":0},"action":"insert","lines":["\t86: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" id=\"zoomInButton\" value=\"+\" onclick=\"zoomIn();\" disabled=\"disabled\"/><br/>","\t87: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" value=\"&ndash;\" onclick=\"zoomOut();\"/>","\t97: <div id=\"information\" style=\"opacity:0.8; background-color:#fff; position:absolute; top:704px; width:100%; border: 1px solid #c8c8c8; margin-left:-1px; pointer-events:auto;\">","",""]},{"start":{"row":7,"column":0},"end":{"row":8,"column":0},"action":"insert","lines":["/mainstylesheet.css:",""]},{"start":{"row":8,"column":0},"end":{"row":10,"column":0},"action":"insert","lines":["\t76:   pointer-events:auto;","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":10,"column":0},"end":{"row":11,"column":0},"action":"insert","lines":["Found 4 matches in 2 files ",""]},{"start":{"row":11,"column":0},"end":{"row":12,"column":0},"action":"insert","lines":["",""]},{"start":{"row":0,"column":59},"end":{"row":0,"column":88},"action":"insert","lines":[" (Found 4 matches in 2 files)"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":12,"column":0},"action":"remove","lines":["Searching for \u0001pointer-events:auto;\u0001 in\u0001the entire project\u0001 (Found 4 matches in 2 files)","","/index.html:","\t86: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" id=\"zoomInButton\" value=\"+\" onclick=\"zoomIn();\" disabled=\"disabled\"/><br/>","\t87: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" value=\"&ndash;\" onclick=\"zoomOut();\"/>","\t97: <div id=\"information\" style=\"opacity:0.8; background-color:#fff; position:absolute; top:704px; width:100%; border: 1px solid #c8c8c8; margin-left:-1px; pointer-events:auto;\">","","/mainstylesheet.css:","\t76:   pointer-events:auto;","","Found 4 matches in 2 files ","",""]},{"start":{"row":0,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["Searching for \u0001pointer-events:auto;\u0001 in\u0001the active file\u0001","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":0},"end":{"row":3,"column":0},"action":"insert","lines":["/index.html:",""]},{"start":{"row":3,"column":0},"end":{"row":8,"column":0},"action":"insert","lines":["\t86: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" id=\"zoomInButton\" value=\"+\" onclick=\"zoomIn();\" disabled=\"disabled\"/><br/>","\t87: <input style=\"width:25px; height:25px; font-size:12pt; pointer-events:auto;\" type=\"button\" value=\"&ndash;\" onclick=\"zoomOut();\"/>","\t97: <div id=\"information\" style=\"opacity:0.8; background-color:#fff; position:absolute; top:704px; width:100%; border: 1px solid #c8c8c8; margin-left:-1px; pointer-events:auto;\">","","Found 3 matches in 1 file ",""]}]}],[{"group":"doc","deltas":[{"start":{"row":8,"column":0},"end":{"row":9,"column":0},"action":"insert","lines":["",""]},{"start":{"row":0,"column":56},"end":{"row":0,"column":84},"action":"insert","lines":[" (Found 3 matches in 1 file)"]}]}]]},"ace":{"folds":[],"customSyntax":"c9search","scrolltop":4.5,"scrollleft":0,"selection":{"start":{"row":9,"column":0},"end":{"row":9,"column":0},"isBackwards":false},"options":{"tabSize":4,"useSoftTabs":true,"guessTabSize":false,"useWrapMode":false,"wrapToView":true},"firstLineState":0}}